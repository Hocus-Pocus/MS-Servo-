
MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 1
MC68HC908GP32 User Bootloader


                        1  ;***************************************************
                                                      *************************
                        2  ;
                        3  ;                         MS_Servo_V1.asm 10/10/05
                        4  ;
                        5  ;       By Robert Hiebert with technical assistance 
                                                              from Dan Williams
                        6  ;
                        7  ;***************************************************
                                                      *************************
                        8  
                        9  ;***************************************************
                                                      *************************
                       10  ; -------------------------------- Background 
                                                 ------------------------------
                       11  ;
                       12  ; - This was developed to control a servo operated 
                                                       choke on the Holley 4160
                       13  ;   marine carburetor. OEM equipment on a 1993 
                                                   Bayliner 3288 with twin Ford
                       14  ;   351 CID Windsor engines, the original bimetal 
                                                           electric chokes were
                       15  ;   difficult to set up for all conditions, and 
                                                      tended to run the engines
                       16  ;   rich until fully warmed up. Manual chokes were 
                                                        impractical to install,
                       17  ;   given the configuration and length of cables 
                                                     involved. This system uses
                       18  ;   Hitec HS-311 servo motors, as used in model 
                                                      aircraft etc., to control
                       19  ;   the choke plate angle. They run on a regulated 
                                                          5 volt supply as part
                       20  ;   of the controller unit. The chokes for both 
                                                         engines are controlled
                       21  ;   individually by dash mounted pots. Each engine 
                                                         has a dash mounted 2x7
                       22  ;   segment display to indicate percent of pot 
                                                        position, which is also
                       23  ;   percent of choke position, from 0% to 99%. 
                                                          There is no automatic
                       24  ;   control, or choke angle feed back. It is up to 
                                                         the operator to adjust
                       25  ;   the throttle and choke angle to where the 
                                                        engine runs best at the
                       26  ;   desired engine speed and given engine temperatur
                                                           e. This assumes that
                       27  ;   the ignition system is in a good state of tune, 
                                                              and that the idle
                       28  ;   mixtures and idle speed throttle stop is set 
                                                                     correctly.
                       29  ;
                       30  ;   The code follows the same format as the code 
                                                    used in Megasquirt and it's
                       31  ;   derivitives and is extensively commented, as 
                                                        much for our benefit as
                       32  ;   for those wishing to understand it for their 
                                                         modifications. It uses
                       33  ;   Megatune for communication, and to change the 


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 2
MC68HC908GP32 User Bootloader


                                                             flash configurable
                       34  ;   constants.
                       35  ;   None of this would be possible if not for the 
                                                       brilliant work of all of
                       36  ;   those connected with the MS projects. In 
                                                     particular, Bruce Bowling,
                       37  ;   Al Grippo, Magnus Bjelk, Tom Hafner, Lance 
                                                       Gardiner, Eric Fahlgren,
                       38  ;   and a host of others I don't know of.
                       39  ;
                       40  ;***************************************************
                                                      *************************
                       41  
                       42  ****************************************************
                                                      *************************
                       43  **   M E G A S Q U I R T - 2 0 0 1 - V2.00
                       44  **
                       45  **   (C) 2002 - B. A. Bowling And A. C. Grippo
                       46  **
                       47  **   This header must appear on all derivatives of 
                                                                     this code.
                       48  **
                       49  ****************************************************
                                                      *************************
                       50  
                       51  ;***************************************************
                                                      *************************
                       52  ;
                       53  ; ------------------------- MS_Servo Hardware 
                                                 Wiring  ----------------------
                       54  ;
                       55  ;***************************************************
                                                      *************************
                       56  ;
                       57  ; ----- Power Terminal [ Port Name - Function - 
                                                              Terminal# ] -----
                       58  ;
                       59  ;               12 Volt input                      
                                                         - Power Terminal Pin 1
                       60  ;               Common ground input                
                                                         - Power Terminal Pin 2
                       61  ;               Servo Stbd 5V supply               
                                                         - Power Terminal Pin 3
                       62  ;  PTD5/T1CH1 - Servo Stbd signal                  
                                                         - Power Terminal Pin 4
                       63  ;               Servo Stbd common ground           
                                                         - Power Terminal Pin 5
                       64  ;               Servo Port 5V supply               
                                                         - Power Terminal Pin 6
                       65  ;  PTD4/T1CH0 - Servo Port signal                  
                                                         - Power Terminal Pin 7
                       66  ;               Servo Port common ground           
                                                         - Power Terminal Pin 8
                       67  ;
                       68  ; ----- ADC outputs [ Port Name - Function - Pin# ] 
                                                                          -----
                       69  ;
                       70  ;  VDD-AD - Vref Stbd 5V output          - Stbd 


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 3
MC68HC908GP32 User Bootloader


                                                                    DB15 Pin 10
                       71  ;  VDD-AD - Vref Port 5V output          - Port 
                                                                    DB15 Pin 10
                       72  ;           Common ground                - Stbd and 
                                                      Port DB15s Pins  11,12,13
                       73  ;
                       74  ; ----- Inputs [ Port Name - Function - Pin# ] -----
                       75  ;
                       76  ;  PTB0/AD0  - ADC0 (not used)                      
                                                                       - No Pin
                       77  ;  PTB1/AD1  - ADC1 (not used)                      
                                                                       - No Pin
                       78  ;  PTB2/AD2  - Control Potentiometer Stbd           
                                                             - Stbd DB15 Pin 11
                       79  ;  PTB3/AD3  - Control Potentiometer Port           
                                                             - Port DB15 Pin 11
                       80  ;  PTB4/AD4  - Battery Voltage/Boot Loader Entry    
                                                                       - No Pin
                       81  ;  PTB5/AD5  - ADC5 (not used)                      
                                                                       - No Pin
                       82  ;  PTB6/AD6  - ADC6 (not used)                      
                                                                       - No Pin
                       83  ;  PTB7/AD7  - ADC7 (not used)                      
                                                                       - No Pin
                       84  ;  IRQ       - external interrupt (not used)        
                                                                       - No Pin
                       85  ;
                       86  ; ----- Outputs [Port Name - Function - Pin#] -----
                       87  ;
                       88  ;  PTA0      - Input "A"                            
                                                                 - SN7448 Pin 7
                       89  ;  PTA1      - Input "B"                            
                                                                 - SN7448 Pin 1
                       90  ;  PTA2      - Input "C"                            
                                                                 - SN7448 Pin 2
                       91  ;  PTA3      - Input "D"                            
                                                                 - SN7448 Pin 4
                       92  ;  PTA4      - Stbd LSD display common cathode 
                                                           driver base - No Pin
                       93  ;  PTA5      - Stbd MSD display common cathode 
                                                           driver base - No Pin
                       94  ;  PTA6      - Port LSD display common cathode 
                                                           driver base - No Pin
                       95  ;  PTA7      - Port MSD display common cathode 
                                                           driver base - No Pin
                       96  ;  PTC0       - (not used)                          
                                                                       - No Pin
                       97  ;  PTC1       - (not used)                          
                                                                       - No Pin
                       98  ;  PTC2       - (not used)                          
                                                                       - No Pin
                       99  ;  PTC3       - (not used)                          
                                                                       - No Pin
                      100  ;  PTC4       - (not used)                          
                                                                       - No Pin
                      101  ;  PTD0/SS    - (not used)                          
                                                                       - No Pin
                      102  ;  PTD1/MISO  - (not used)                          


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 4
MC68HC908GP32 User Bootloader


                                                                       - No Pin
                      103  ;  PTD2/MOSI  - (not used)                          
                                                                       - No Pin
                      104  ;  PTD3/SPSCK - Program Loop Counter LED driver 
                                                            base       - No Pin
                      105  ;
                      106  ; ----- Communications [ Port Name - Function - 
                                                                   Pin# ] -----
                      107  ;
                      108  ;  PTE0/TxD       - SCI receive data input        - 
                                                         MAX 232 Pin 11 (T1 in)
                      109  ;  PTE1/RxD       - SCI transmit data output      - 
                                                        MAX 232 Pin 12 (R1 out)
                      110  ;  MAX 232 Pin 14 - T1 out                        - 
                                                                      DB9 Pin 2
                      111  ;  MAX 232 Pin 13 - R1 in                         - 
                                                                      DB9 Pin 3
                      112  ;  MAX 232 Pin 16 - VCC                           - 
                                                                      DB9 Pin 1
                      113  ;  MAX 232 Pin 15 - Ground                        - 
                                                                   DB9 Pins 5,9
                      114  
                      115  ;
                      116  ; ----- SN7448 Outputs [ Pin# - Function - Pin# ] 
                                                                          -----
                      117  ;
                      118  ;  SN7448 Pin 9  - Segment "e"               - Stbd 
                                                           and Port DB15s Pin 3
                      119  ;  SN7448 Pin 10 - Segment "d"               - Stbd 
                                                           and Port DB15s Pin 2
                      120  ;  SN7448 Pin 11 - Segment "c"               - Stbd 
                                                          and Port DB15s Pin 14
                      121  ;  SN7448 Pin 12 - Segment "b"               - Stbd 
                                                           and Port DB15s Pin 7
                      122  ;  SN7448 Pin 13 - Segment "a"               - Stbd 
                                                           and Port DB15s Pin 8
                      123  ;  SN7448 Pin 14 - Segment "g"               - Stbd 
                                                          and Port DB15s Pin 15
                      124  ;  SN7448 Pin 15 - Segment "f"               - Stbd 
                                                           and Port DB15s Pin 4
                      125  ;
                      126  ; ----- Common Cathode Driver Outputs [ Function - 
                                                                   Pin# ] -----
                      127  ;
                      128  ;  Stbd LSD display common cathode driver collector 
                                                              - Stbd DB15 Pin 6
                      129  ;  Stbd MSD display common cathode driver collector 
                                                              - Stbd DB15 Pin 5
                      130  ;  Port LSD display common cathode driver collector 
                                                              - Port DB15 Pin 6
                      131  ;  Port MSD display common cathode driver collector 
                                                              - Port DB15 Pin 5
                      132  ;
                      133  ;***************************************************
                                                      *************************
                      134  
                      135  ;***************************************************
                                                      *************************


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 5
MC68HC908GP32 User Bootloader


                      136  
                      137  
 0040                 138       org      ram_start              ; Origin  Memory location $0040=64
 0040                 139       include "MS_Servo_V1.inc"       ; Include definitions for
                      140  ;****************************************************************************
                      141  ;
                      142  ;          MS_Servo_V1.inc (header file for MS_Servo_V1.asm)  10/10/05
                      143  ;
                      144  ;         By Robert Hiebert with technical assistance from Dan Williams
                      145  ;
                      146  ;****************************************************************************
                      147  
                      148  ;****************************************************************************
                      149  ;
                      150  ; ------------------------- MS_Servo Hardware Wiring  ----------------------
                      151  ;
                      152  ;****************************************************************************
                      153  ;
                      154  ; ----- Power Terminal [ Port Name - Function - Terminal# ] -----
                      155  ;
                      156  ;               12 Volt input                      - Power Terminal Pin 1
                      157  ;               Common ground input                - Power Terminal Pin 2
                      158  ;               Servo Stbd 5V supply               - Power Terminal Pin 3
                      159  ;  PTD5/T1CH1 - Servo Stbd signal                  - Power Terminal Pin 4
                      160  ;               Servo Stbd common ground           - Power Terminal Pin 5
                      161  ;               Servo Port 5V supply               - Power Terminal Pin 6
                      162  ;  PTD4/T1CH0 - Servo Port signal                  - Power Terminal Pin 7
                      163  ;               Servo Port common ground           - Power Terminal Pin 8
                      164  ;
                      165  ; ----- ADC outputs [ Port Name - Function - Pin# ] -----
                      166  ;
                      167  ;  VDD-AD - Vref Stbd 5V output          - Stbd DB15 Pin 10
                      168  ;  VDD-AD - Vref Port 5V output          - Port DB15 Pin 10
                      169  ;           Common ground                - Stbd and Port DB15s Pins  11,12,13
                      170  ;
                      171  ; ----- Inputs [ Port Name - Function - Pin# ] -----
                      172  ;
                      173  ;  PTB0/AD0  - ADC0 (not used)                             - No Pin
                      174  ;  PTB1/AD1  - ADC1 (not used)                             - No Pin
                      175  ;  PTB2/AD2  - Control Potentiometer Stbd                  - Stbd DB15 Pin 11
                      176  ;  PTB3/AD3  - Control Potentiometer Port                  - Port DB15 Pin 11
                      177  ;  PTB4/AD4  - Battery Voltage/Boot Loader Entry           - No Pin
                      178  ;  PTB5/AD5  - ADC5 (not used)                             - No Pin
                      179  ;  PTB6/AD6  - ADC6 (not used)                             - No Pin
                      180  ;  PTB7/AD7  - ADC7 (not used)                             - No Pin
                      181  ;  IRQ       - external interrupt (not used)               - No Pin
                      182  ;
                      183  ; ----- Outputs [Port Name - Function - Pin#] -----
                      184  ;
                      185  ;  PTA0      - Input "A"                                   - SN7448 Pin 7
                      186  ;  PTA1      - Input "B"                                   - SN7448 Pin 1
                      187  ;  PTA2      - Input "C"                                   - SN7448 Pin 2
                      188  ;  PTA3      - Input "D"                                   - SN7448 Pin 4
                      189  ;  PTA4      - Stbd LSD display common cathode driver base - No Pin
                      190  ;  PTA5      - Stbd MSD display common cathode driver base - No Pin
                      191  ;  PTA6      - Port LSD display common cathode driver base - No Pin
                      192  ;  PTA7      - Port MSD display common cathode driver base - No Pin
                      193  ;  PTC0       - (not used)                                 - No Pin
                      194  ;  PTC1       - (not used)                                 - No Pin
                      195  ;  PTC2       - (not used)                                 - No Pin
                      196  ;  PTC3       - (not used)                                 - No Pin
                      197  ;  PTC4       - (not used)                                 - No Pin
                      198  ;  PTD0/SS    - (not used)                                 - No Pin
                      199  ;  PTD1/MISO  - (not used)                                 - No Pin
                      200  ;  PTD2/MOSI  - (not used)                                 - No Pin
                      201  ;  PTD3/SPSCK - Program Loop Counter LED driver base       - No Pin
                      202  ;
                      203  ; ----- Communications [ Port Name - Function - Pin# ] -----
                      204  ;
                      205  ;  PTE0/TxD       - SCI receive data input        - MAX 232 Pin 11 (T1 in)
                      206  ;  PTE1/RxD       - SCI transmit data output      - MAX 232 Pin 12 (R1 out)
                      207  ;  MAX 232 Pin 14 - T1 out                        - DB9 Pin 2
                      208  ;  MAX 232 Pin 13 - R1 in                         - DB9 Pin 3
                      209  ;  MAX 232 Pin 16 - VCC                           - DB9 Pin 1
                      210  ;  MAX 232 Pin 15 - Ground                        - DB9 Pins 5,9
                      211  
                      212  ;
                      213  ; ----- SN7448 Outputs [ Pin# - Function - Pin# ] -----
                      214  ;
                      215  ;  SN7448 Pin 9  - Segment "e"               - Stbd and Port DB15s Pin 3
                      216  ;  SN7448 Pin 10 - Segment "d"               - Stbd and Port DB15s Pin 2
                      217  ;  SN7448 Pin 11 - Segment "c"               - Stbd and Port DB15s Pin 14
                      218  ;  SN7448 Pin 12 - Segment "b"               - Stbd and Port DB15s Pin 7
                      219  ;  SN7448 Pin 13 - Segment "a"               - Stbd and Port DB15s Pin 8
                      220  ;  SN7448 Pin 14 - Segment "g"               - Stbd and Port DB15s Pin 15
                      221  ;  SN7448 Pin 15 - Segment "f"               - Stbd and Port DB15s Pin 4
                      222  ;
                      223  ; ----- Common Cathode Driver Outputs [ Function - Pin# ] -----
                      224  ;
                      225  ;  Stbd LSD display common cathode driver collector    - Stbd DB15 Pin 6
                      226  ;  Stbd MSD display common cathode driver collector    - Stbd DB15 Pin 5
                      227  ;  Port LSD display common cathode driver collector    - Port DB15 Pin 6
                      228  ;  Port MSD display common cathode driver collector    - Port DB15 Pin 5
                      229  ;
                      230  ;****************************************************************************
                      231  
                      232  ;****************************************************************************
                      233  ; ------------------------ Input Port Equates ------------------------------
                      234  ;****************************************************************************
                      235  
                      236  
                      237  
                      238  
                      239  ;****************************************************************************
                      240  ; ------------------------ Output Port Equates ------------------------------
                      241  ;****************************************************************************
                      242  
 0040                 243  SLSD        equ 4     ; Stbd LSD common cathode driver base on PTA4
 0040                 244  SMSD        equ 5     ; Stbd MSD common cathode driver base on PTA5
 0040                 245  PLSD        equ 6     ; Port LSD common cathode driver base on PTA6
 0040                 246  PMSD        equ 7     ; Port MSD common cathode driver base on PTA7
 0040                 247  LoopFrq     equ 3     ; Loop frequency counter on PTD3
 0040                 248  SrvS        equ 5     ; Servo Stbd signal on PTD5
 0040                 249  SrvP        equ 4     ; Servo Port signal on PTD4
                      250  
                      251  
                      252  ;****************************************************************************
                      253  ; ---------------- "inputs" Operating Status bit field equates --------------
                      254  ;****************************************************************************
                      255  
 0040                 256  clk10       equ 0     ; 1 = 0.01S   clock tick flag    0 = "clk10" cleared
 0040                 257  adcc        equ 1     ; 1 = ADC complete flag          0 = "adcc" cleared
 0040                 258  pwp         equ 2     ; 1 = TIM1 50 HZ timer overflow  0 = "pwp" cleared
                      259  
                      260  ;****************************************************************************
                      261  ; ----------------- RAM Variables (512 bytes available) ---------------------
                      262  ; I/O registers from $0000 to $0039 (decimal 0 to 63)
                      263  ; Direct page addressing from $0000 to $00FF (decimal 0 to 255)
                      264  ; Ram end at $023F (decimal 575)
                      265  ;****************************************************************************
                      266  
                      267  ;Memory Location $0040 (decimal 64)
                      268  
                      269  ms_ram_start:
                      270  
                      271  ;****************************************************************************


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 6
MC68HC908GP32 User Bootloader


                      272  ; ------------------ RS232 Real Time Download Variables --------------------
                      273  ;****************************************************************************
                      274  
 0040                 275  secH:         ds 1     ; Seconds counter, Hi byte
 0041                 276  secL:         ds 1     ; Seconds counter, Lo byte
 0042                 277  PotSpos:      ds 1     ; Control pot Stbd position, 8 bit ADC reading
 0043                 278  PotPpos:      ds 1     ; Control pot Port position, 8 bit ADC reading
 0044                 279  Bat:          ds 1     ; Battery Voltage, 8 bit ADC reading
 0045                 280  PotSpct:      ds 1     ; PotS % of full voltage (0-99)
 0046                 281  PotPpct:      ds 1     ; PotP % of full voltage (0-99)
 0047                 282  Volts:        ds 1     ; Battery voltage to 0.1V resolution
 0048                 283  SBCD:         ds 1     ; PotSpct expressed in BCD
 0049                 284  PBCD:         ds 1     ; PotPpct expressed in BCD
 004A                 285  SLSDBCD:      ds 1     ; Stbd Least Significant Digit BCD value
 004B                 286  SMSDBCD:      ds 1     ; Stbd Most Significant Digit BCD value
 004C                 287  PLSDBCD:      ds 1     ; Port Least Significant Digit BCD value
 004D                 288  PMSDBCD:      ds 1     ; Port Most Significant Digit BCD value
 004E                 289  SSpwMnH:      ds 1     ; Servo S OC value at open choke Hi byte
 004F                 290  SSpwMnL:      ds 1     ; Servo S OC value at open choke Lo byte
                      291  
                      292  ;Memory Location $0050 (decimal 80)
                      293  
 0050                 294  SSpwMxH:      ds 1     ; Servo S OC value at closed choke Hi byte
 0051                 295  SSpwMxL:      ds 1     ; Servo S OC value at closed choke Lo byte
 0052                 296  SSpwSpnH:     ds 1     ; Servo S span Hi byte
 0053                 297  SSpwSpnL:     ds 1     ; Servo 0 span Lo byte (SSpwMxH:SSpwMxL -
                      298                         ; SSpwMnH:SSpwMnL = SSpwSpnH:SSpwSpnL)
 0054                 299  SSmulH:       ds 1     ; Servo S multiplicand Hi byte
 0055                 300  SSmulM:       ds 1     ; Servo S multiplicand Mid byte
 0056                 301  SSmulL:       ds 1     ; Servo S multiplicand Lo byte
                      302                         ;(SSpwSpnH:SSpwSpnL * PotSpos = SSmulH:SSmulM:SSmulL)
 0057                 303  SSposH:       ds 1     ; Servo S commanded position Hi byte
 0058                 304  SSposL:       ds 1     ; Servo S commanded position Lo byte
                      305                         ;(SSmulH:SSmulM:SSmulL / 256 = SSposH:SSposL)
 0059                 306  SrvSpwH:      ds 1     ; Servo S OC for commanded position Hi byte
 005A                 307  SrvSpwL:      ds 1     ; Servo S OC for commanded position Lo byte
                      308                         ;(SSposH:SSposL + SSpwMnH:SSpwMnL = SrvSpwH:SrvSpwL)
 005B                 309  SPpwMnH:      ds 1     ; Servo P OC value at open choke Hi byte
 005C                 310  SPpwMnL:      ds 1     ; Servo P OC value at open choke Lo byte
 005D                 311  SPpwMxH:      ds 1     ; Servo P OC value at closed choke Hi byte
 005E                 312  SPpwMxL:      ds 1     ; Servo P OC value at closed choke Lo byte
 005F                 313  SPpwSpnH:     ds 1     ; Servo P span Hi byte
                      314  
                      315  ;Memory Location $0060 (decimal 96)
                      316  
 0060                 317  SPpwSpnL:     ds 1     ; Servo P span Lo byte (SPpwMxH:SPpwMxL -
                      318                         ; SPpwMnH:SPpwMnL = SPpwSpnH:SPpwSpnL)
 0061                 319  SPmulH:       ds 1     ; Servo P multiplicand Hi byte
 0062                 320  SPmulM:       ds 1     ; Servo P multiplicand Mid byte
 0063                 321  SPmulL:       ds 1     ; Servo P multiplicand Lo byte
                      322                         ;(SPpwSpnH:SPpwSpnL * PotPpos = SPmulH:SPmulM:SPmulL)
 0064                 323  SPposH:       ds 1     ; Servo P commanded position Hi byte
 0065                 324  SPposL:       ds 1     ; Servo P commanded position Lo byte
                      325                         ;(SPmulH:SPmulM:SPmulL / 256 = SPposH:SPposL)
 0066                 326  SrvPpwH:      ds 1     ; Servo P OC for commanded position Hi byte
 0067                 327  SrvPpwL:      ds 1     ; Servo P OC for commanded position Lo byte
                      328                         ;(SPposH:SPposL + SPpwMnH:SPpwMnL = SrvPpwH:SrvPpwL)
                      329  
                      330  
                      331  ;****************************************************************************
                      332  ; This marks the end of the real time download variables, 40 in total
                      333  ;****************************************************************************
                      334  
                      335  ;****************************************************************************
                      336  ; ----------------------- Time Clock Variables ------------------------------
                      337  ; - NOTE! ";*"  denotes that this variable is listed with RS232 variables
                      338  ;****************************************************************************
                      339  
 0068                 340  uSx100:         ds 1  ; 100 Microseconds counter
 0069                 341  mS:             ds 1  ; 1 Millisecond counter
 006A                 342  mSx10:          ds 1     ; 10 Milliseconds counter
 006B                 343  mSx20:          ds 1     ; 20 Milliseconds counter
 006C                 344  mSx100:         ds 1     ; 100 Milliseconds counter
                      345  ;*secL:           ds 1     ; Seconds counter, Lo byte
                      346  ;*secH:           ds 1     ; Seconds counter, Hi byte
                      347  
                      348  
                      349  ;****************************************************************************
                      350  ; --------------------- 8 bit ADC input Variables --------------------------
                      351  ; ----------------- (ordered list from "ADC0" to "Bat") --------------------
                      352  ; - NOTE! ";*"  denotes that this variable is listed with RS232 variables
                      353  ;****************************************************************************
                      354  
                      355  ;*PotSpos:      ds 1     ; Control pot S position, 8 bit ADC reading
                      356  ;*PotPpos:      ds 1     ; Control pot P position, 8 bit ADC reading
                      357  ;*Bat:          ds 1     ; Battery Voltage, 8 bit ADC reading
 006D                 358  adsel:          ds 1     ; ADC Selector Variable
                      359  
                      360  ;****************************************************************************
                      361  ; --------------------- ADC Conversion Variables --------------------------
                      362  ; - NOTE! ";*"  denotes that this variable is listed with RS232 variables
                      363  ;****************************************************************************
                      364  
                      365  ;*PotSPct:      ds 1     ; PotS % of full voltage (0-99)
                      366  ;*PotPPct:      ds 1     ; PotP % of full voltage (0-99)
                      367  ;*Volts:        ds 1     ; Battery voltage to 0.1V resolution
                      368  
                      369  ;****************************************************************************
                      370  ; ------------------- Display Calculation Variables ------------------------
                      371  ; - NOTE! ";*"  denotes that this variable is listed with RS232 variables
                      372  ;****************************************************************************
                      373  
                      374  ;*SBCD:         ds 1     ; PotSpct expressed in BCD
                      375  ;*PBCD:         ds 1     ; PotPpct expressed in BCD
                      376  ;*SLSDBCD:      ds 1     ; Stbd Least Significant Digit BCD value
                      377  ;*SMSDBCD:      ds 1     ; Stbd Most Significant Digit BCD value
                      378  ;*PLSDBCD:      ds 1     ; Port Least Significant Digit BCD value
                      379  ;*PMSDBCD:      ds 1     ; Port Most Significant Digit BCD value
                      380  
                      381  ;****************************************************************************
                      382  ; ------------------- Servo PW Calculation Variables ------------------------
                      383  ; - NOTE! ";*"  denotes that this variable is listed with RS232 variables
                      384  ;****************************************************************************
                      385  
                      386  ;*SSpwMnH:      ds 1     ; Servo S OC value at open choke Hi byte
                      387  ;*SSpwMnL:      ds 1     ; Servo S OC value at open choke Lo byte
                      388  ;*SSpwMxH:      ds 1     ; Servo S OC value at closed choke Hi byte
                      389  ;*SSpwMxL:      ds 1     ; Servo S OC value at closed choke Lo byte
                      390  ;*SSpwSpnH:     ds 1     ; Servo S span Hi byte
                      391  ;*SSpwSpnL:     ds 1     ; Servo 0 span Lo byte (SSpwMxH:SSpwMxL -
                      392                         ; SSpwMnH:SSpwMnL = SSpwSpnH:SSpwSpnL)
                      393  ;*SSmulH:       ds 1     ; Servo S multiplicand Hi byte
                      394  ;*SSmulM:       ds 1     ; Servo S multiplicand Mid byte
                      395  ;*SSmulL:       ds 1     ; Servo S multiplicand Lo byte
                      396                         ;(SSpwSpnH:SSpwSpnL * PotSpos = SSmulH:SSmulM:SSmulL)
                      397  ;*SSposH:       ds 1     ; Servo S commanded position Hi byte
                      398  ;*SSposL:       ds 1     ; Servo S commanded position Lo byte
                      399                         ;(SSmulH:SSmulM:SSmulL / 256 = SSposH:SSposL)
                      400  ;*SrvSpwH:      ds 1     ; Servo S OC for commanded position Hi byte
                      401  ;*SrvSpwL:      ds 1     ; Servo S OC for commanded position Lo byte
                      402                         ;(SSposH:SSposL + SSpwMnH:SSpwMnL = SrvSpwH:SrvSpwL)
                      403  ;*SPpwMnH:      ds 1     ; Servo P OC value at open choke Hi byte
                      404  ;*SPpwMnL:      ds 1     ; Servo P OC value at open choke Lo byte
                      405  ;*SPpwMxH:      ds 1     ; Servo P OC value at closed choke Hi byte
                      406  ;*SPpwMxL:      ds 1     ; Servo P OC value at closed choke Lo byte
                      407  ;*SPpwSpnH:     ds 1     ; Servo P span Hi byte


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 7
MC68HC908GP32 User Bootloader


                      408  ;*SPpwSpnL:     ds 1     ; Servo P span Lo byte (SPpwMxH:SPpwMxL -
                      409                         ; SPpwMnH:SPpwMnL = SPpwSpnH:SPpwSpnL)
                      410  ;*SPmulH:       ds 1     ; Servo P multiplicand Hi byte
                      411  ;*SPmulM:       ds 1     ; Servo P multiplicand Mid byte
                      412  ;*SPmulL:       ds 1     ; Servo P multiplicand Lo byte
                      413                         ;(SPpwSpnH:SPpwSpnL * PotPpos = SPmulH:SPmulM:SPmulL)
                      414  ;*SPposH:       ds 1     ; Servo P commanded position Hi byte
                      415  ;*SPposL:       ds 1     ; Servo P commanded position Lo byte
                      416                         ;(SPmulH:SPmulM:SPmulL / 256 = SPposH:SPposL)
                      417  ;*SrvPpwH:      ds 1     ; Servo P OC for commanded position Hi byte
                      418  ;*SrvPpwL:      ds 1     ; Servo P OC for commanded position Lo byte
                      419                         ;(SPposH:SPposL + SPpwMnH:SPpwMnL = SrvPpwH:SrvPpwL)
                      420  
                      421   ;****************************************************************************
                      422  ; --------------------- Status Bit Field Variables --------------------------
                      423  ; - NOTE! ";*"  denotes that this variable is listed with RS232 variables
                      424  ;****************************************************************************
                      425  
 006E                 426  inputs:         ds 1     ; Input status bit field variable
                      427  
                      428  ;****************************************************************************
                      429  ; ----------------------- Variables for integer math ------------------------
                      430  ;****************************************************************************
                      431  
 006F                 432  INTACC1:      rmb 4
                      433  
                      434   ;Memory Location $0070 (decimal 112) at INTACC1+1)
                      435  
 0073                 436  INTACC2:      rmb 4
                      437  
                      438  ;****************************************************************************
                      439  ; ------------------------ Temporary variables ------------------------------
                      440  ;****************************************************************************
                      441  
 0077                 442  tmp1          ds     1
 0078                 443  tmp2          ds     1
 0079                 444  tmp3          ds     1
 007A                 445  tmp4          ds     1
 007B                 446  tmp5          ds     1
 007C                 447  tmp6          ds     1
 007D                 448  tmp7          ds     1
 007E                 449  tmp8          ds     1
 007F                 450  tmp9          ds     1
                      451  
                      452  ;Memory Location $0080 (decimal 128)
                      453  
 0080                 454  tmp10         ds     1
 0081                 455  tmp11         ds     1
 0082                 456  tmp12         ds     1
 0083                 457  tmp13         ds     1
 0084                 458  tmp14         ds     1
 0085                 459  tmp15         ds     1
 0086                 460  tmp16         ds     1
 0087                 461  tmp17         ds     1
 0088                 462  tmp18         ds     1
 0089                 463  tmp19         ds     1
 008A                 464  tmp20         ds     1
 008B                 465  tmp21         ds     1
 008C                 466  local_tmp     ds     1
                      467  
                      468  ;****************************************************************************
                      469  ; ------- Serial Communications Interface Parameters and Variables ---------
                      470  ;****************************************************************************
                      471  
 008D                 472  txcnt:        ds 1     ; SCI transmitter count (incremented)
 008E                 473  txgoal:       ds 1     ; SCI number of bytes to transmit
 008F                 474  txmode:       ds 1     ; Transmit mode flag
                      475  
                      476  ;Memory Location $0090 (decimal 144)
                      477  
 0090                 478  rxoffset:     ds 1     ; Offset placeholder when receiving VE/constants
                      479                         ; vis. SCI
                      480  
                      481  ;****************************************************************************
                      482  ; --------------------- Flash Burner Routine Variables ----------------------
                      483  ;****************************************************************************
                      484  
 0091                 485  burnSrc:      ds 2T    ; Burn routine variable
 0093                 486  burnDst:      ds 2T    ; Burn routine variable
 0095                 487  burnCount:    ds 1T    ; Burn routine variable
                      488  
                      489  ;****************************************************************************
                      490  ; ----------------------------- Misc. Variables -----------------------------
                      491  ;****************************************************************************
                      492  
 0096                 493  LoopCntr:      ds 1     ; Loop counter for main loop frequency check
 0097                 494  dsel:          ds 1     ; Display sequencing counter
 0098                 495  Spare1:        ds 1     ; Blank place holder for 16 byte increments
 0099                 496  Spare2:        ds 1     ; Blank place holder for 16 byte increments
 009A                 497  Spare3:        ds 1     ; Blank place holder for 16 byte increments
 009B                 498  Spare4:        ds 1     ; Blank place holder for 16 byte increments
 009C                 499  Spare5:        ds 1     ; Blank place holder for 16 byte increments
 009D                 500  Spare6:        ds 1     ; Blank place holder for 16 byte increments
 009E                 501  Spare7:        ds 1     ; Blank place holder for 16 byte increments
 009F                 502  Spare8:        ds 1     ; Blank place holder for 16 byte increments
                      503  
                      504  
                      505  ;Memory Location $00A0 (decimal 160)
                      506  
                      507  ms_ram_end:
                      508  
                      509  ;****************************************************************************
                      510  ; -------------------- Flash Configuration constants ------------------------
                      511  ;  "SSpwMnH" is entry point, everything is offset from this point.
                      512  ;****************************************************************************
                      513  
                      514  ms_rf_start:
                      515  
 00A0                 516  SSpwMnH_F   rmb $01     ; Servo S OC value at open choke Hi byte (flash)
 00A1                 517  SSpwMnL_F   rmb $01     ; Servo S OC value at open choke Lo byte (flash)
 00A2                 518  SSpwMxH_F   rmb $01     ; Servo S OC value at closed choke Hi byte (flash)
 00A3                 519  SSpwMxL_F   rmb $01     ; Servo S OC value at closed choke Lo byte (flash)
 00A4                 520  SPpwMnH_F   rmb $01     ; Servo P OC value at open choke Hi byte (flash)
 00A5                 521  SPpwMnL_F   rmb $01     ; Servo P OC value at open choke Lo byte (flash)
 00A6                 522  SPpwMxH_F   rmb $01     ; Servo P OC value at closed choke Hi byte (flash)
 00A7                 523  SPpwMxL_F   rmb $01     ; Servo P OC value at closed choke Lo byte (flash)
 00A8                 524  Blank       rmb $40     ; 56 Blank place holders for 64 byte increments
                      525  
                      526  ;Memory Location $00E0 (decimal 224)
                      527  
                      528  ms_rf_end:
                      529  
                      530  ;****************************************************************************
                      531  ; ---------------------------- Misc. Equates --------------------------------
                      532  ;****************************************************************************
                      533  
 00E8                 534  ms_ram_size       equ {ms_ram_end-ms_ram_start}
 00E8                 535  ms_rf_size        equ {ms_rf_end-ms_rf_start}
 00E8                 536  ms_total_ram_size equ {ms_rf_end-ms_ram_start}
                      537  
                      538  
                      539  
                      540  
                      541                                       ; MS_Servo_V1.asm
                      542  
                      543  ;***************************************************************************


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 8
MC68HC908GP32 User Bootloader


                      544  ;
                      545  ; Main Routine Here - Initialization and main loop
                      546  ;
                      547  ; Note: Org down 256 bytes below the "rom_start" point
                      548  ;       because of erase bug in bootloader routine
                      549  ;
                      550  ; Note: Items commented out after the Start entry point are
                      551  ;       taken care of in the Boot_R12.asm code
                      552  ;
                      553  ;***************************************************************************
                      554  
                      555  
 8256                 556       org     {rom_start + 256}  ; Origin at memory location
                      557                                 ; $8000+256 = 32,768+256 = 33,024=$8100
                      558  
                      559  Start:
 8256 [03] 4501ED     560       ldhx    #init_stack+1      ; Load index register with value in
                      561                                 ; init_stack+1(Set the stack Pointer)
 8259 [02] 94         562       txs                      ; Transfer value in index register Lo byte
                      563                                 ; to stack
                      564                                 ;(Move before burner to avoid conflict)
                      565  
                      566  ;* Note - uncomment this code if you do not use the Bootloader to initilize *
                      567  ;       clra
                      568  ;    sta     copctl
                      569  ;    mov     #%00000001,config2
                      570  ;    mov     #%00001001,config1
                      571  ;    mov     #%00000001,config1
                      572  ;    ldhx    #ram_last+1        ; Set the stack Pointer
                      573  ;    txs                      ; to the bottom of RAM
                      574  
                      575  ;****************************************************************************
                      576  ; - Set the phase lock loop for a bus frequency of 8.003584mhz
                      577  ;  (Boot loader initially sets it at 7.3728mhz)
                      578  ;****************************************************************************
                      579  
                      580  ;PllSet:
 825A [04] 1936       581       bclr     BCS,PCTL       ; Select external Clock Reference
 825C [04] 1B36       582       bclr     PLLON,PCTL     ; Turn off PLL
 825E [04] 6E0236     583       mov      #$02,PCTL      ; Move %00000010 into PLL Control Register
                      584                               ;(PLL Interrupts Disabled)
                      585                               ;(No change in lock condition(flag))
                      586                               ;(PLL off)
                      587                               ;(CGMXCLK divided by 2 drives CGMOUT)
                      588                               ;(VCO pwr of 2 mult = 1(E=0))
                      589                               ;(Prescale mult = 4(P=2))
 8261 [04] 6E0338     590       mov      #$03,PMSH      ; Move %00000011 into PLL Multiplier Select
                      591                               ; Register Hi (Set N MSB)
 8264 [04] 6ED139     592       mov      #$D1,PMSL      ; Move %11010001 into PLL Multiplier Select
                      593                               ; Register Lo (Set N LSB)($84 for 7.37 MHz)
 8267 [04] 6ED03A     594       mov      #$D0,PMRS      ; Move %11010000 into PLL VCO Range Select
                      595                               ; Register (Set L) ($C0 for 7.37 MHz)
 826A [04] 6E013B     596       mov      #$01,PMDS      ; Move %00000001 into Reference Divider Select
                      597                               ; Register (Set "RDS0" bit (default value of 1)
 826D [04] 1E37       598       bset     AUTO,PBWC      ; Set "Auto" bit of PLL Bandwidth Control Register
 826F [04] 1A36       599       bset     PLLON,PCTL     ; Turn on PLL
                      600  
                      601  PLL_WAIT:
 8271 [05] 0D37FD     602       brclr   LOCK,PBWC,PLL_WAIT     ; If "Lock" bit of PLL Bandwidth Control
                      603                                      ; Register is clear, branch to PLL_WAIT:
 8274 [04] 1836       604       bset    BCS,PCTL               ; Set "BCS" bit of PLL Control Register
                      605                                      ;(CGMXCLK divided by 2 drives CGMOUT)
                      606                                      ;(Select VCO as base clock)
                      607  
                      608  ;****************************************************************************
                      609  ; ------------- Set up the port data-direction registers --------------------
                      610  ;               Set directions,
                      611  ;               Preset state of pins to become outputs
                      612  ;               Set all unused pins to outputs initialized Lo
                      613  ;****************************************************************************
                      614  
                      615  ;****************************************************************************
                      616  ; - Port A SN7448 Display Driver Control
                      617  ;****************************************************************************
                      618  
                      619  ; Port A
 8276 [03] 3F00       620       clr     PORTA           ; Clear Port A Data Register
                      621                               ;(Preinit all pins low)
 8278 [02] A6FF       622       lda     #$FF            ; Load accumulator with %11111111
                      623                               ;(port direction setup 1 = output)
 827A [03] B704       624       sta     DDRA            ; Copy to Port A Data Direction Register
                      625                               ; Set all as outputs (Port MSD,Port LSD,
                      626                               ; Stbd LSD,Stbd MSD,"D","C","B","A")
                      627  
                      628  ;****************************************************************************
                      629  ; - Set up ADC inputs
                      630  ;****************************************************************************
                      631  
                      632  ; Port B
 827C [03] 3F01       633       clr     PORTB           ; Clear Port B Data Register
                      634                               ;(Preinit all pins low)
 827E [03] 3F05       635       clr     DDRB            ; Clear Port B Data Direction Register
                      636                               ;(Set as ADC inputs, "ADSEL" selects channel)
                      637  
                      638  ;****************************************************************************
                      639  ; - Port C not used
                      640  ;****************************************************************************
                      641  
                      642  ; Port C
 8280 [03] 3F02       643       clr     PORTC           ; Clear Port C Data Register
                      644                               ;(Preinit all pins low)
 8282 [02] A6FF       645       lda     #$FF            ; Load accumulator with %11111111
                      646                               ;(port direction setup 1 = output)
 8284 [03] B706       647       sta     DDRC            ; Copy to Port C Data Direction Register
                      648                               ;(Set all as outputs
                      649                               ; NA,NA,NA,NA,NA,NA,NA,NA)
                      650  
                      651  ;****************************************************************************
                      652  ; - Set Port D for servo control
                      653  ;****************************************************************************
                      654  
                      655  ; Port D
 8286 [03] 3F03       656       clr     PORTD           ; Clear Port D Data Register
                      657                               ;(Preinit all pins low)
 8288 [02] A6FF       658       lda     #$FF            ; Load accumulator with %11111111
                      659                               ;(port direction setup 1 = output)
 828A [03] B707       660       sta     DDRD            ; Copy to Port D Data Direction Register
                      661                               ;(Set all as outputs
                      662                               ; NA,NA,Stbd Srv,Port Srv,LoopFrq,NA,NA,NA)
                      663  
                      664  ;****************************************************************************
                      665  ; - Set up Port E.(The Motorola manual states that it is not necessarry to
                      666  ;   set up Port E when SCI is enabled, but we'll do it anyway).
                      667  ;****************************************************************************
                      668  
                      669  ; Port E
 828C [03] 3F08       670       clr     PORTE           ; Clear Port E Data Register (to avoid glitches)
 828E [02] A601       671       lda     #$01            ; Load accumulator with %00000001
                      672                               ; (set up port directions, 1 = out)
                      673                               ; (Serial Comm Port)
 8290 [03] B70C       674       sta     DDRE            ; Copy to Port E Data Direction Register
                      675  
                      676  
                      677  ;****************************************************************************
                      678  ; Set up TIM2 as a free running ~1us counter. Set Channel 0 output compare
                      679  ; to generate the ~100us(0.1ms) clock tick interrupt vector "TIM2CH0_ISR:"


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 9
MC68HC908GP32 User Bootloader


                      680  ;****************************************************************************
                      681  
 8292 [04] 6E332B     682       mov     #$33,T2SC       ; Move %00110011 into Timer2
                      683                               ; Status and Control Register
                      684                               ;(Disable interrupts, stop timer)
                      685                               ;(Prescale and counter cleared))
                      686                               ;(Prescale for bus frequency / 8)
 8295 [04] 6EFF2E     687       mov     #$FF,T2MODH     ; Move decimal 255 into T2 modulo reg Hi
 8298 [04] 6EFF2F     688       mov     #$FF,T2MODL     ; Move decimal 255 into T2 modulo reg Lo
                      689                               ;(free running timer)
 829B [04] 6E0031     690       mov     #$00,T2CH0H     ; Move decimal 0 into T1CH0 O/C register Hi
 829E [04] 6E6432     691       mov     #$64,T2CH0L     ; Move decimal 100 into T1CH0 O/C register Lo
                      692                               ;(~100uS)=(~0.1ms)
 82A1 [04] 6E5430     693       mov     #$54,T2SC0      ; Move %01010100 into Timer2
                      694                               ; channel 0 status and control register
                      695                               ; (Output compare, interrupt enabled)
 82A4 [04] 6E032B     696       mov     #$03,T2SC       ; Move %00000011 into Timer2
                      697                               ; Status and Control Register
                      698                               ; Disable overflow interrupts, counter active
                      699                               ; Prescale for bus frequency / 8
                      700                               ; 8,003584hz/8=1000448hz
                      701                               ; = .0000009995sec
                      702  
                      703  
                      704  ;****************************************************************************
                      705  ; Set up TIM1 as a modulo count up 50 HZ timer (20mS period) with 1uS
                      706  ; resolution, for servo signal control timing. Set channels 0 and 1 for
                      707  ; output compare, pulsewidth control of servos. Mid point @ 1500 uS, full
                      708  ; left @ 1100 uS, full right at 1900 uS.
                      709  ; Servo Port on T1SC0 and Servo Stbd on T1SC1, initialize for 0 uS pulse
                      710  ; width so that the servo doesn't move until it gets a valid signal.
                      711  ; Interrupt vector "TIM1OV_ISR:"
                      712  ;****************************************************************************
                      713  
 82A7 [04] 6E3320     714       mov     #$33,T1SC       ; Move %00110011 into Timer1
                      715                               ; Status and Control Register
                      716                               ;(Disable interrupts, stop timer)
                      717                               ;(Prescale and counter cleared))
                      718                               ;(Prescale for bus frequency / 8)
 82AA [04] 6E4E23     719       mov     #$4E,T1MODH     ; Move decimal 78 into T1 modulo reg Hi
 82AD [04] 6E2024     720       mov     #$20,T1MODL     ; Move decimal 32 into T1 modulo reg Lo
                      721                               ;(20,000 x 1uS = 20mS)
 82B0 [03] 3F26       722       clr     T1CH0H          ; Clear T1CH0 register Hi
 82B2 [03] 3F27       723       clr     T1CH0L          ; Clear T1CH0 register Lo
 82B4 [03] 3F29       724       clr     T1CH1H          ; Clear T1CH1 register Hi
 82B6 [03] 3F2A       725       clr     T1CH1L          ; Clear T1CH1 register Lo
 82B8 [04] 6E1E25     726       mov     #$1E,T1SC0      ; Move %00011110 into Timer1
                      727                               ; Channel 0 Status and Control Register
                      728                               ;(Channel 0 interrupt requests disabled,)
                      729                               ;(Buffered OC disabled, set output on compare)
                      730                               ;(toggle in overflow)
 82BB [04] 6E1E28     731       mov     #$1E,T1SC1      ; Move %000111110 into Timer1
                      732                               ; Channel 1 Status and Control Register
                      733                               ;(Channel 1 interrupt requests disabled,)
                      734                               ;(Buffered OC disabled, set output on compare)
                      735                               ;(toggle in overflow)
 82BE [04] 6E4320     736       mov     #$43,T1SC       ; Move %01000011 into Timer1
                      737                               ; Status and Control Register
                      738                               ; Enable overflow interrupts, counter active
                      739                               ; Prescale for bus frequency / 8
                      740                               ; 8,003584hz/8=1000448hz
                      741                               ; = .0000009995sec
                      742  
                      743  
                      744  ;****************************************************************************
                      745  ; - Set up Serial Communications Interface Module
                      746  ;****************************************************************************
                      747  
 82C1 [02] A630       748       lda      #$30           ; Load accumulator with %110000
 82C3 [03] B719       749       sta      SCBR           ; Copy to SCI Baud Rate Register
                      750                               ; 8003584/(64*13*1)=9619.7 baud
 82C5 [04] 1C13       751       bset     ensci,SCC1     ; Set enable SCI bit of SCI Control Register 1
                      752                               ; (Enable SCI)
 82C7 [04] 1414       753       bset     RE,SCC2        ; Set receiver enable bit of SCI Control Reg. 2
                      754                               ; (Enable receiver)
 82C9 [04] 1A14       755       bset     SCRIE,SCC2     ; Set SCI receive interrupt enable bit of
                      756                               ; SCI Control Register 2 (Enable Rcv. Interrupt)
 82CB [03] B616       757       lda      SCS1           ; Load accumulator with SCI Status Register 1
                      758                               ; (Clear SCI transmitter Empty Bit)
 82CD [03] 3F8D       759       clr      txcnt          ; Clear SCI transmitter count
                      760                               ; (incremented)(characters transmitted)
 82CF [03] 3F8E       761       clr      txgoal         ; Clear SCI number of bytes to transmit
                      762                               ; (characters to be transmitted)
                      763  
                      764  
                      765  ;****************************************************************************
                      766  ; - Load the configurable constants from Flash to RAM
                      767  ;****************************************************************************
                      768  
 82D1 [01] 8C         769       clrh                        ; Clear index register Hi byte
 82D2 [01] 5F         770       clrx                        ; Clear index register Lo byte
                      771  
                      772  load_ram:
 82D3 [04] D6E100     773       lda     ms_rf_start_f,x     ; Load accumulator with value in
                      774                                   ; "ms_rf_start_f" table, offset in index
                      775                                   ; register Lo byte
 82D6 [03] E7A0       776       sta     ms_rf_start,x       ; Copy to "ms_rf_start" table, offset in
                      777                                   ; index register Lo byte
 82D8 [02] AF01       778       aix     #1                  ; Add immediate value (1)to index register
                      779                                   ; H:X<_(H:X)+(16<<M)
 82DA [03] 650048     780       cphx    #ms_rf_size         ; Compare index register with memory
                      781                                   ; (H:X)-(M:M+$0001)
 82DD [03] 26F4       782       bne     load_ram            ; If the Z bit of CCR is clear, branch to
                      783                                   ; load_ram:
                      784  
                      785  
                      786  ;****************************************************************************
                      787  ; - Clear all variables
                      788  ;****************************************************************************
                      789  
 82DF [03] 3F40       790       clr     secH       ; Seconds counter, Hi byte
 82E1 [03] 3F41       791       clr     secL       ; Seconds counter, Lo byte
 82E3 [03] 3F42       792       clr     PotSpos    ; Control pot Stbd position, 8 bit ADC reading
 82E5 [03] 3F43       793       clr     PotPpos    ; Control pot Port position, 8 bit ADC reading
 82E7 [03] 3F44       794       clr     Bat        ; Battery Voltage, 8 bit ADC reading
 82E9 [03] 3F45       795       clr     PotSpct    ; PotS % of full voltage (0-99)
 82EB [03] 3F46       796       clr     PotPpct    ; PotP % of full voltage (0-99)
 82ED [03] 3F47       797       clr     Volts      ; Battery voltage to 0.1V resolution
 82EF [03] 3F48       798       clr     SBCD       ; PotSpct expressed in BCD
 82F1 [03] 3F49       799       clr     PBCD       ; PotPpct expressed in BCD
 82F3 [03] 3F4A       800       clr     SLSDBCD    ; Stbd Least Significant Digit BCD value
 82F5 [03] 3F4B       801       clr     SMSDBCD    ; Stbd Most Significant Digit BCD value
 82F7 [03] 3F4C       802       clr     PLSDBCD    ; Port Least Significant Digit BCD value
 82F9 [03] 3F4D       803       clr     PMSDBCD    ; Port Most Significant Digit BCD value
 82FB [03] 3F4E       804       clr     SSpwMnH    ; Servo S OC value at open choke Hi byte
 82FD [03] 3F4F       805       clr     SSpwMnL    ; Servo S OC value at open choke Lo byte
 82FF [03] 3F50       806       clr     SSpwMxH    ; Servo S OC value at closed choke Hi byte
 8301 [03] 3F51       807       clr     SSpwMxL    ; Servo S OC value at closed choke Lo byte
 8303 [03] 3F52       808       clr     SSpwSpnH   ; Servo S span Hi byte
 8305 [03] 3F53       809       clr     SSpwSpnL   ; Servo 0 span Lo byte (SSpwMxH:SSpwMxL -
                      810                          ; SSpwMnH:SSpwMnL = SSpwSpnH:SSpwSpnL)
 8307 [03] 3F54       811       clr     SSmulH     ; Servo S multiplicand Hi byte
 8309 [03] 3F55       812       clr     SSmulM     ; Servo S multiplicand Mid byte
 830B [03] 3F56       813       clr     SSmulL     ; Servo S multiplicand Lo byte
                      814                          ;(SSpwSpnH:SSpwSpnL * PotSpos = SSmulH:SSmulM:SSmulL)
 830D [03] 3F57       815       clr     SSposH     ; Servo S commanded position Hi byte


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 10
MC68HC908GP32 User Bootloader


 830F [03] 3F58       816       clr     SSposL     ; Servo S commanded position Lo byte
                      817                          ;(SSmulH:SSmulM:SSmulL / 256 = SSposH:SSposL)
 8311 [03] 3F59       818       clr     SrvSpwH    ; Servo S OC for commanded position Hi byte
 8313 [03] 3F5A       819       clr     SrvSpwL    ; Servo S OC for commanded position Lo byte
                      820                          ;(SSposH:SSposL + SSpwMnH:SSpwMnL = SrvSpwH:SrvSpwL)
 8315 [03] 3F5B       821       clr     SPpwMnH    ; Servo P OC value at open choke Hi byte
 8317 [03] 3F5C       822       clr     SPpwMnL    ; Servo P OC value at open choke Lo byte
 8319 [03] 3F5D       823       clr     SPpwMxH    ; Servo P OC value at closed choke Hi byte
 831B [03] 3F5E       824       clr     SPpwMxL    ; Servo P OC value at closed choke Lo byte
 831D [03] 3F5F       825       clr     SPpwSpnH   ; Servo P span Hi byte
 831F [03] 3F60       826       clr     SPpwSpnL   ; Servo P span Lo byte (SPpwMxH:SPpwMxL -
                      827                          ; SPpwMnH:SPpwMnL = SPpwSpnH:SPpwSpnL)
 8321 [03] 3F61       828       clr     SPmulH     ; Servo P multiplicand Hi byte
 8323 [03] 3F62       829       clr     SPmulM     ; Servo P multiplicand Mid byte
 8325 [03] 3F63       830       clr     SPmulL     ; Servo P multiplicand Lo byte
                      831                          ;(SPpwSpnH:SPpwSpnL * PotPpos = SPmulH:SPmulM:SPmulL)
 8327 [03] 3F64       832       clr     SPposH     ; Servo P commanded position Hi byte
 8329 [03] 3F65       833       clr     SPposL     ; Servo P commanded position Lo byte
                      834                          ;(SPmulH:SPmulM:SPmulL / 256 = SPposH:SPposL)
 832B [03] 3F66       835       clr     SrvPpwH    ; Servo P OC for commanded position Hi byte
 832D [03] 3F67       836       clr     SrvPpwL    ; Servo P OC for commanded position Lo byte
                      837                          ;(SPposH:SPposL + SPpwMnH:SPpwMnL = SrvPpwH:SrvPpwL)
 832F [03] 3F68       838       clr     uSx100     ; 100 Microseconds counter
 8331 [03] 3F69       839       clr     mS         ; 1 Millisecond counter
 8333 [03] 3F6A       840       clr     mSx10      ; 10 Milliseconds counter
 8335 [03] 3F6B       841       clr     mSx20      ; 20 Milliseconds counter
 8337 [03] 3F6C       842       clr     mSx100     ; 100 Milliseconds counter
 8339 [03] 3F6D       843       clr     adsel      ; ADC Selector Variable
 833B [03] 3F6F       844       clr     INTACC1    ; Variable for integer math
 833D [03] 3F73       845       clr     INTACC2    ; Variable for integer math
 833F [03] 3F77       846       clr     tmp1       ; Temporary variable
 8341 [03] 3F78       847       clr     tmp2       ; Temporary variable
 8343 [03] 3F79       848       clr     tmp3       ; Temporary variable
 8345 [03] 3F7A       849       clr     tmp4       ; Temporary variable
 8347 [03] 3F7B       850       clr     tmp5       ; Temporary variable
 8349 [03] 3F7C       851       clr     tmp6       ; Temporary variable
 834B [03] 3F7D       852       clr     tmp7       ; Temporary variable
 834D [03] 3F7E       853       clr     tmp8       ; Temporary variable
 834F [03] 3F7F       854       clr     tmp9       ; Temporary variable
 8351 [03] 3F80       855       clr     tmp10      ; Temporary variable
 8353 [03] 3F81       856       clr     tmp11      ; Temporary variable
 8355 [03] 3F82       857       clr     tmp12      ; Temporary variable
 8357 [03] 3F83       858       clr     tmp13      ; Temporary variable
 8359 [03] 3F84       859       clr     tmp14      ; Temporary variable
 835B [03] 3F85       860       clr     tmp15      ; Temporary variable
 835D [03] 3F86       861       clr     tmp16      ; Temporary variable
 835F [03] 3F87       862       clr     tmp17      ; Temporary variable
 8361 [03] 3F88       863       clr     tmp18      ; Temporary variable
 8363 [03] 3F89       864       clr     tmp19      ; Temporary variable
 8365 [03] 3F8A       865       clr     tmp20      ; Temporary variable
 8367 [03] 3F8B       866       clr     tmp21      ; Temporary variable
 8369 [03] 3F8C       867       clr     local_tmp  ; Temporary variable
 836B [03] 3F8D       868       clr     txcnt      ; SCI transmitter count (incremented)
 836D [03] 3F8E       869       clr     txgoal     ; SCI number of bytes to transmit
 836F [03] 3F8F       870       clr     txmode     ; Transmit mode flag
 8371 [03] 3F90       871       clr     rxoffset   ; Offset placeholder when receiving VE/constants
 8373 [03] 3F91       872       clr     burnSrc    ; Burn routine variable
 8375 [03] 3F93       873       clr     burnDst    ; Burn routine variable
 8377 [03] 3F95       874       clr     burnCount  ; Burn routine variable
 8379 [03] 3F96       875       clr     LoopCntr   ; Loop counter for main loop frequency check
 837B [03] 3F97       876       clr     dsel       ; Display sequencing counter
 837D [03] 3F98       877       clr     Spare1     ; Blank place holder for 16 byte increments
 837F [03] 3F99       878       clr     Spare2     ; Blank place holder for 16 byte increments
 8381 [03] 3F9A       879       clr     Spare3     ; Blank place holder for 16 byte increments
 8383 [03] 3F9B       880       clr     Spare4     ; Blank place holder for 16 byte increments
 8385 [03] 3F9C       881       clr     Spare5     ; Blank place holder for 16 byte increments
 8387 [03] 3F9D       882       clr     Spare6     ; Blank place holder for 16 byte increments
 8389 [03] 3F9E       883       clr     Spare7     ; Blank place holder for 16 byte increments
 838B [03] 3F9F       884       clr     Spare8     ; Blank place holder for 16 byte increments
                      885  
                      886  ;****************************************************************************
                      887  ; - Copy the Servo Min and Max pulse width values from RAM to direct page
                      888  ;   (just in case the program expands to place these out of direct page)
                      889  ;****************************************************************************
                      890  
 838D [03] B6A0       891       lda     SSpwMnH_F     ; Servo S OC value at open choke Hi byte (flash)
 838F [03] B74E       892       sta     SSpwMnH       ; Servo S OC value at open choke Hi byte
 8391 [03] B6A1       893       lda     SSpwMnL_F     ; Servo S OC value at open choke Lo byte (flash)
 8393 [03] B74F       894       sta     SSpwMnL       ; Servo S OC value at open choke Lo byte
 8395 [03] B6A2       895       lda     SSpwMxH_F     ; Servo S OC value at closed choke Hi byte (flash)
 8397 [03] B750       896       sta     SSpwMxH       ; Servo S OC value at closed choke Hi byte
 8399 [03] B6A3       897       lda     SSpwMxL_F     ; Servo S OC value at closed choke Lo byte (flash)
 839B [03] B751       898       sta     SSpwMxL       ; Servo S OC value at closed choke Lo byte
 839D [03] B6A4       899       lda     SPpwMnH_F     ; Servo P OC value at open choke Hi byte (flash)
 839F [03] B75B       900       sta     SPpwMnH       ; Servo P OC value at open choke Hi byte
 83A1 [03] B6A5       901       lda     SPpwMnL_F     ; Servo P OC value at open choke Lo byte (flash)
 83A3 [03] B75C       902       sta     SPpwMnL       ; Servo P OC value at open choke Lo byte
 83A5 [03] B6A6       903       lda     SPpwMxH_F     ; Servo P OC value at closed choke Hi byte (flash)
 83A7 [03] B75D       904       sta     SPpwMxH       ; Servo P OC value at closed choke Hi byte
 83A9 [03] B6A7       905       lda     SPpwMxL_F     ; Servo P OC value at closed choke Lo byte (flash)
 83AB [03] B75E       906       sta     SPpwMxL       ; Servo P OC value at closed choke Lo byte
                      907  
                      908  ;****************************************************************************
                      909  ; - Calculate the Servo pulse width spans
                      910  ;   SSpwMxH:SSpwMxL - SSpwMnH:SSpwMnL = SSpwSpnH:SSpwSpnL
                      911  ;   SPpwMxH:SPpwMxL - SPpwMnH:SPpwMnL = SPpwSpnH:SPpwSpnL
                      912  ;****************************************************************************
                      913  
 83AD [03] B651       914       lda     SSpwMxL     ; Load accumulato with value in "SSpwMxL"
 83AF [03] B04F       915       sub     SSpwMnL     ; Subtract A<-(A)-(M)
 83B1 [03] B753       916       sta     SSpwSpnL    ; Copy result to "SSpwSpnL"
 83B3 [03] B650       917       lda     SSpwMxH     ; Load accumulator with value in "SSpwMxH"
 83B5 [03] B24E       918       sbc     SSpwMnH     ; Subtract with carry A<-(A)-(M)-(C)
 83B7 [03] B752       919       sta     SSpwSpnH    ; Copy result to "SSpwSpnH"
 83B9 [03] B65E       920       lda     SPpwMxL     ; Load accumulato with value in "SPpwMxL"
 83BB [03] B05C       921       sub     SPpwMnL     ; Subtract A<-(A)-(M)
 83BD [03] B760       922       sta     SPpwSpnL    ; Copy result to "SPpwSpnL"
 83BF [03] B65D       923       lda     SPpwMxH     ; Load accumulator with value in "SPpwMxH"
 83C1 [03] B25B       924       sbc     SPpwMnH     ; Subtract with carry A<-(A)-(M)-(C)
 83C3 [03] B75F       925       sta     SPpwSpnH    ; Copy result to "SPpwSpnH"
                      926  
                      927  ;****************************************************************************
                      928  ; - Set up clock source for ADC
                      929  ;   Do an initial conversion just to stabilize the ADC
                      930  ;****************************************************************************
                      931  
                      932  Stb_ADC:
 83C5 [02] A670       933       lda     #$70                 ; Load accumulator with %01110000
 83C7 [03] B73E       934       sta     ADCLK                ; Copy to ADC Clock Register
                      935                                    ;( bus clock/8 = ~1mhz )
 83C9 [02] A602       936       lda     #$02                 ; Load accumulator with %00000010
                      937                                    ;(one conversion, no interrupt, chan AD2)
 83CB [03] B73C       938       sta     ADSCR                ; Copy to ADC Status and Control Register
                      939  
                      940  ADCWait:
 83CD [05] 0F3CFD     941       brclr   coco,ADSCR,ADCWait   ; If "conversions complete flag" bit of
                      942                                    ; ADC Status and Control Register is clear
                      943                                    ; branch to ADCWait lable
                      944                                    ;(keep looping while COnversion
                      945                                    ; COmplete flag = 0)
 83D0 [03] B63D       946       lda     ADR                  ; Load accumulator with value in ADC Result
                      947                                    ; Variable (read value from ADc Result)
 83D2 [03] B742       948       sta     PotSpos              ; Copy to Control Pot Stbd position,
                      949                                    ; 8 bit ADC reading
                      950  
                      951  ;****************************************************************************


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 11
MC68HC908GP32 User Bootloader


                      952  ; - Now get valid ADC readings for Pot positions and battery voltage
                      953  ;****************************************************************************
                      954  
 83D4 [02] A602       955       lda     #$02                 ; Load accumulator with %00000010
                      956                                    ;(one conversion, no interrupt, chan AD2)
 83D6 [03] B73C       957       sta     ADSCR                ; Copy to ADC Status and Control Register
                      958  
                      959  ADCWait1:
 83D8 [05] 0F3CFD     960       brclr   coco,ADSCR,ADCWait1  ; If "conversions complete flag" bit of
                      961                                    ; ADC Status and Control Register is clear
                      962                                    ; branch to ADCWait1:
                      963                                    ;(keep looping while COnversion
                      964                                    ; COmplete flag = 0)
 83DB [03] B63D       965       lda     ADR                  ; Load accumulator with value in ADC Result
                      966                                    ; Variable (read value from ADc Result)
 83DD [03] B742       967       sta     PotSpos              ; Copy to Control Pot Stbd position,
                      968                                    ; 8 bit ADC reading
 83DF [02] A603       969       lda     #$03                 ; Load accumulator with %00000011
                      970                                    ;(one conversion, no interrupt, chan AD3)
 83E1 [03] B73C       971       sta     ADSCR                ; Copy to ADC Status and Control Register
                      972  
                      973  ADCWait2:
 83E3 [05] 0F3CFD     974       brclr   coco,ADSCR,ADCWait2  ; If "conversions complete flag" bit of
                      975                                    ; ADC Status and Control Register is clear
                      976                                    ; branch to ADCWait2:
                      977                                    ;(keep looping while COnversion
                      978                                    ; COmplete flag = 0)
 83E6 [03] B63D       979       lda     ADR                  ; Load accumulator with value in ADC Result
                      980                                    ; Variable (read value from ADc Result)
 83E8 [03] B743       981       sta     PotPpos              ; Copy to Control Pot Port position,
                      982                                    ; 8 bit ADC reading
 83EA [02] A604       983       lda     #$04                 ; Load accumulator with %00000100
                      984                                    ;(one conversion, no interrupt, chan AD4)
 83EC [03] B73C       985       sta     ADSCR                ; Copy to ADC Status and Control Register
                      986  
                      987  ADCWait3:
 83EE [05] 0F3CFD     988       brclr   coco,ADSCR,ADCWait3  ; If "conversions complete flag" bit of
                      989                                    ; ADC Status and Control Register is clear
                      990                                    ; branch to ADCWait3:
                      991                                    ;(keep looping while COnversion
                      992                                    ; COmplete flag = 0)
 83F1 [03] B63D       993       lda     ADR                  ; Load accumulator with value in ADC Result
                      994                                    ; Variable (read value from ADc Result)
 83F3 [03] B744       995       sta     Bat                  ; Copy to Battery Voltage 8 bit ADC reading
 83F5 [04] 6E026D     996       mov     #$02,adsel           ; Move decimal 2 to ADC channel selector
                      997  
                      998  
                      999  ;****************************************************************************
                     1000  ;- Enable Interrupts
                     1001  ;****************************************************************************
                     1002  
 83F8 [02] 9A        1003       cli                          ; Clear intrupt mask
                     1004                                    ;( Turn on all interrupts now )
                     1005  
                     1006  
                     1007  ;****************************************************************************
                     1008  ;****************************************************************************
                     1009  ;********************    M A I N  E V E N T  L O O P     ********************
                     1010  ;****************************************************************************
                     1011  ;****************************************************************************
                     1012  
                     1013  ;****************************************************************************
                     1014  ; - Toggle pin 3 on Port D each program loop so frequency can be checked
                     1015  ;   with a frequency meter or scope. (for program developement)
                     1016  ;****************************************************************************
                     1017  
                     1018  LOOPER:
 83F9 [04] 3396      1019       com     LoopCntr         ; Ones compliment "LoopCntr"
                     1020                                ;(flip state of "LoopCntr")
 83FB [03] 2604      1021       bne     SET_LOOPCHK      ; If the Z bit of CCR is clear, branch
                     1022                                ; to SET_LOOPCHK
 83FD [04] 1703      1023       bclr    LoopFrq,PORTD    ; Clear bit 3 of Port D (Program Loop LED)
 83FF [03] 2002      1024       bra     LOOPCHK_DONE     ; Branch to LOOPCHK_DONE:
                     1025  
                     1026  SET_LOOPCHK:
 8401 [04] 1603      1027       bset    LoopFrq,PORTD    ; Set bit 3 of Port D (Program Loop LED)
                     1028  
                     1029  LOOPCHK_DONE:
                     1030  
                     1031  
                     1032  ;****************************************************************************
                     1033  ; - Update the ADC readings and conversions. This is done only once per ADC
                     1034  ;   conversion completion, in the first pass through the main loop after the
                     1035  ;   ADC_ISR Interrupt routine has been completed.
                     1036  ;****************************************************************************
                     1037  
 8403 [05] 026E03    1038       brset   adcc,inputs,ADC_LOOKUPS  ; If "adcc" bit of "inputs" variable
                     1039                                        ; is set, branch to ADC_LOOKUPS:
 8406 [03] CC84A1    1040       jmp     NO_ADC_PASS              ; Jump to NO_ADC_PASS:
                     1041  
                     1042  ADC_LOOKUPS:
                     1043  
                     1044  ;****************************************************************************
                     1045  ; - Calculate the percent of total voltage read from Pot 0 and Pot 1, and
                     1046  ;   store as "Pot0pct" and "Pot1pct". This is a linear interpolation, with the
                     1047  ;   "Pot0pos" and "Pot1pos" values ranging from 0 to 255, and "Pot0pct" and
                     1048  ;   "Pot1pct" values ranging from 0 to 99. (to fit in a 2x7 segment display)
                     1049  ;
                     1050  ; Method where:
                     1051  ; PotSpos  = Stbd Pot ADC reading
                     1052  ; PotSpct  = Stbd Pot percent of total voltage (0-99)
                     1053  ; PotPpos  = Port Pot ADC reading
                     1054  ; PotPpct  = Port Pot percent of total voltage (0-99)
                     1055  ;
                     1056  ; Graph Plot        X2
                     1057  ;                   Y2
                     1058  ;               X
                     1059  ;               Y
                     1060  ;         X1
                     1061  ;         Y1
                     1062  ;            (Y2 - Y1)
                     1063  ;  Y = Y1 +  --------- * (X - X1)
                     1064  ;            (X2 - X1)
                     1065  ;
                     1066  ;   tmp1 = X1 = 0
                     1067  ;   tmp2 = X2 = 255
                     1068  ;   tmp3 = Y1 = 100
                     1069  ;   tmp4 = Y2 = 0
                     1070  ;   tmp5 = X  = PotSpos or PotPpos
                     1071  ;   tmp6 = Y  = PotSpos or PotPpct
                     1072  ;
                     1073  ;****************************************************************************
                     1074  
                     1075  ;****************************************************************************
                     1076  ; - Stbd pot calculations
                     1077  ;****************************************************************************
                     1078  
                     1079  POTSP_CALC:
 8409 [03] B642      1080       lda     PotSpos        ; Load accumulator with value in "PotSpos"
 840B [02] A101      1081       cmp     #$01           ; Compare value in accumulator with decimal 1
 840D [03] 2319      1082       bls     POTS_LOW       ; If A<=decimal 1, branch to POTS_LOW:
 840F [02] A1FD      1083       cmp     #$FD           ; Compare value in accumulator with decimal 253
 8411 [03] 241A      1084       bhs     POTS_HI        ; If A>= decimal 253, branch to POTS_HI:
 8413 [03] 3F77      1085       clr     tmp1           ; Clear tmp1 variable
 8415 [03] 3F7A      1086       clr     tmp4           ; Clear tmp4 variable
 8417 [04] 6EFF78    1087       mov     #$FF,tmp2      ; Move decimal 255 to tmp2 variable


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 12
MC68HC908GP32 User Bootloader


 841A [04] 6E6479    1088       mov     #$64,tmp3      ; Move decimal 100 to tmp3 variable
 841D [05] 4E427B    1089       mov     PotSpos,tmp5   ; Move value in "PotSpos" to tmp5 variable
 8420 [05] CD86A3    1090       jsr     lininterp      ; Jump to Liniterp subroutine (result in tmp6)
 8423 [05] 4E7C45    1091       mov     tmp6,PotSpct   ; Move value in "tmp6" to "PotSpct"
 8426 [03] 2008      1092       bra     S_BCD_CALC     ; Branch to S_BCD_CALC:
                     1093  
                     1094  POTS_LOW:
 8428 [04] 6E0045    1095       mov     #$00,PotSpct   ; Move decimal 0 to "PotSpct"
 842B [03] 2003      1096       bra     S_BCD_CALC     ; Branch to S_BCD_CALC:
                     1097  
                     1098  POTS_HI:
 842D [04] 6E6345    1099       mov     #$63,PotSpct   ; Move decimal 99 to "PotSpct"
                     1100  
                     1101  ;****************************************************************************
                     1102  ; - Determine the BCD value of "PotSpct" by looking up the equivalent value
                     1103  ;   in the "DecBCD" table.
                     1104  ;****************************************************************************
                     1105  
                     1106  S_BCD_CALC:
 8430 [01] 8C        1107       clrh                 ; Clear index register Hi byte
 8431 [01] 5F        1108       clrx                 ; Clear index register Lo byte
 8432 [03] B645      1109       lda     PotSpct      ; Load accumulator with value in "PotSpct"
 8434 [01] 97        1110       tax                  ; Copy to index register Lo byte
 8435 [04] D6F100    1111       lda     DecBCD,x     ; Load accumulator with value in "DecBCD"
                     1112                            ; table, offset in index register Lo byte
 8438 [03] B748      1113       sta     SBCD         ; Copy to "PotSpct" expressed in BCD variable
                     1114  
                     1115  ;****************************************************************************
                     1116  ; - Determine the BCD value for the Stbd display, Least Significant Digit
                     1117  ;****************************************************************************
                     1118  
                     1119  S_LSD_CALC:
                     1120  
 843A [03] B648      1121       lda     SBCD        ; Load accumulator with value in "SBCD"
 843C [03] 62        1122       nsa                 ; Nibble swap accumulator (Lo nibble now Hi nibble)
 843D [01] 44        1123       lsra                ; Logical shift right accumulator
 843E [01] 44        1124       lsra                ; Logical shift right accumulator
 843F [01] 44        1125       lsra                ; Logical shift right accumulator
 8440 [01] 44        1126       lsra                ; Logical shift right accumulator
                     1127                           ;(these 5 instructions clear the Hi nibble
 8441 [02] AA10      1128       ora     #$10        ; Logical "or" value in accumulator with 00010000
                     1129                           ;(result is low nibble BCD with bit 4 set to trigger
                     1130                           ; Stbd LSD common cathode driver transistor
 8443 [03] B74A      1131       sta     SLSDBCD     ; Copy to Stbd Least Significant Digit BCD value
                     1132  
                     1133  ;****************************************************************************
                     1134  ; - Determine the BCD value for the Stbd display, Most Significant Digit
                     1135  ;****************************************************************************
                     1136  
 8445 [03] B648      1137       lda     SBCD        ; Load accumulator with value in "SBCD"
 8447 [01] 44        1138       lsra                ; Logical shift right accumulator
 8448 [01] 44        1139       lsra                ; Logical shift right accumulator
 8449 [01] 44        1140       lsra                ; Logical shift right accumulator
 844A [01] 44        1141       lsra                ; Logical shift right accumulator
                     1142                           ;(these 4 instructions move the value in the Hi
                     1143                           ; nibble to the low nibble and clear the Hi nibble
 844B [02] AA20      1144       ora     #$20        ; Logical "or" value in accumulator with 00100000
                     1145                           ;(result is low nibble BCD with bit 5 set to trigger
                     1146                           ; Stbd MSD common cathode driver transistor
 844D [03] B74B      1147       sta     SMSDBCD     ; Copy to Stbd Most Significant Digit BCD value
                     1148  
                     1149  ;****************************************************************************
                     1150  ; - Port pot calculations
                     1151  ;****************************************************************************
                     1152  
                     1153  POTPP_CALC:
 844F [03] B643      1154       lda     PotPpos        ; Load accumulator with value in "PotPpos"
 8451 [02] A101      1155       cmp     #$01           ; Compare value in accumulator with decimal 1
 8453 [03] 2319      1156       bls     POTP_LOW       ; If A<=decimal 1, branch to POTP_LOW:
 8455 [02] A1FD      1157       cmp     #$FD           ; Compare value in accumulator with decimal 253
 8457 [03] 241A      1158       bhs     POTP_HI        ; If A>= decimal 253, branch to POTP_HI:
 8459 [03] 3F77      1159       clr     tmp1           ; Clear tmp1 variable
 845B [03] 3F7A      1160       clr     tmp4           ; Clear tmp4 variable
 845D [04] 6EFF78    1161       mov     #$FF,tmp2      ; Move decimal 255 to tmp2 variable
 8460 [04] 6E6479    1162       mov     #$64,tmp3      ; Move decimal 100 to tmp3 variable
 8463 [05] 4E437B    1163       mov     PotPpos,tmp5   ; Move value in "PotPpos" to tmp5 variable
 8466 [05] CD86A3    1164       jsr     lininterp      ; Jump to Liniterp subroutine (result in tmp6)
 8469 [05] 4E7C46    1165       mov     tmp6,PotPpct   ; Move value in "tmp6" to "PotPpct"
 846C [03] 2008      1166       bra     P_BCD_CALC     ; Branch to P_BCD_CALC:
                     1167  
                     1168  
                     1169  POTP_LOW:
 846E [04] 6E0046    1170       mov     #$00,PotPpct   ; Move decimal 0 to "PotPpct"
 8471 [03] 2003      1171       bra     P_BCD_CALC     ; Branch to P_BCD_CALC:
                     1172  
                     1173  POTP_HI:
 8473 [04] 6E6346    1174       mov     #$63,PotPpct   ; Move decimal 99 to "PotPpct"
                     1175  
                     1176  
                     1177  ;****************************************************************************
                     1178  ; - Determine the BCD value of "PotPpct" by looking up the equivalent value
                     1179  ;   in the "DecBCD" table.
                     1180  ;****************************************************************************
                     1181  
                     1182  P_BCD_CALC:
 8476 [01] 8C        1183       clrh                 ; Clear index register Hi byte
 8477 [01] 5F        1184       clrx                 ; Clear index register Lo byte
 8478 [03] B646      1185       lda     PotPpct      ; Load accumulator with value in "PotPpct"
 847A [01] 97        1186       tax                  ; Copy to index register Lo byte
 847B [04] D6F100    1187       lda     DecBCD,x     ; Load accumulator with value in "DecBCD"
                     1188                            ; table, offset in index register Lo byte
 847E [03] B749      1189       sta     PBCD         ; Copy to "PotPpct" expressed in BCD variable
                     1190  
                     1191  ;****************************************************************************
                     1192  ; - Determine the BCD value for the Port display, Least Significant Digit
                     1193  ;****************************************************************************
                     1194  
                     1195  P_LSD_CALC:
                     1196  
 8480 [03] B649      1197       lda     PBCD        ; Load accumulator with value in "PBCD"
 8482 [03] 62        1198       nsa                 ; Nibble swap accumulator (Lo nibble now Hi nibble)
 8483 [01] 44        1199       lsra                ; Logical shift right accumulator
 8484 [01] 44        1200       lsra                ; Logical shift right accumulator
 8485 [01] 44        1201       lsra                ; Logical shift right accumulator
 8486 [01] 44        1202       lsra                ; Logical shift right accumulator
                     1203                           ;(these 5 instructions clear the Hi nibble
 8487 [02] AA40      1204       ora     #$40        ; Logical "or" value in accumulator with 01000000
                     1205                           ;(result is low nibble BCD with bit 4 set to trigger
                     1206                           ; Port LSD common cathode driver transistor
 8489 [03] B74C      1207       sta     PLSDBCD     ; Copy to Port Least Significant Digit BCD value
                     1208  
                     1209  ;****************************************************************************
                     1210  ; - Determine the BCD value for the Port display, Most Significant Digit
                     1211  ;****************************************************************************
                     1212  
 848B [03] B649      1213       lda     PBCD        ; Load accumulator with value in "PBCD"
 848D [01] 44        1214       lsra                ; Logical shift right accumulator
 848E [01] 44        1215       lsra                ; Logical shift right accumulator
 848F [01] 44        1216       lsra                ; Logical shift right accumulator
 8490 [01] 44        1217       lsra                ; Logical shift right accumulator
                     1218                           ;(these 4 instructions move the value in the Hi
                     1219                           ; nibble to the low nibble and clear the Hi nibble
 8491 [02] AA80      1220       ora     #$80        ; Logical "or" value in accumulator with 10000000
                     1221                           ;(result is low nibble BCD with bit 5 set to trigger
                     1222                           ; Port MSD common cathode driver transistor
 8493 [03] B74D      1223       sta     PMSDBCD     ; Copy to Port Most Significant Digit BCD value


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 13
MC68HC908GP32 User Bootloader


                     1224  
                     1225  
                     1226  ;****************************************************************************
                     1227  ; - Determine system voltage by looking up the equivalent voltage for "BAT"
                     1228  ;   in the "BatVolt" table.
                     1229  ;****************************************************************************
                     1230  
                     1231  VOLTS_CALC:
 8495 [01] 8C        1232       clrh                    ; Clear index register Hi byte
 8496 [01] 5F        1233       clrx                    ; Clear index register Lo byte
 8497 [03] B644      1234       lda     Bat             ; Load accumulator with value in Battery
                     1235                               ; Voltage 8 bit ADC reading
 8499 [01] 97        1236       tax                     ; Copy to index register Lo byte
 849A [04] D6F000    1237       lda     BatVolt,x       ; Load accumulator with value in "BatVolt"
                     1238                               ; table, offset in index register Lo byte
 849D [03] B747      1239       sta     Volts           ; Copy to Battery Voltage to 0.1V resolution
 849F [04] 136E      1240       bclr    adcc,inputs     ; Clear "adcc" bit of "inputs" variable
                     1241  
                     1242  NO_ADC_PASS:
                     1243  
                     1244  ;****************************************************************************
                     1245  ; - Update the displays. This is done at a frequency of 100 HZ. Every 10Ms,
                     1246  ;   in the first pass through the main loop after the 10mS clock tick has
                     1247  ;   ocurred. The display sequences between Stbd Least Significant Digit,
                     1248  ;   Stbd Most Significant Digit, Port Least Significant Digit, and Port Most
                     1249  ;   Significant Digit.
                     1250  ;****************************************************************************
                     1251  
 84A1 [05] 006E03    1252       brset   clk10,inputs,DISP_SEQ     ; If "clk10" bit of "inputs" variable
                     1253                                         ; is set, branch to DISP_SEQ:
 84A4 [03] CC84C6    1254       jmp     NO_DISP_PASS              ; Jump to NO_DISP_PASS:
                     1255  
                     1256  DISP_SEQ:
 84A7 [03] B697      1257       lda     dsel                ; Load accumulator with value in Display
                     1258                                   ; Sequence Counter variable
 84A9 [04] 41010B    1259       cbeqa   #$01,SET_SMSD       ; Compare value in accumulator with decimal
                     1260                                   ; 1, if equal, branch to SET_SMSD:
 84AC [04] 41020D    1261       cbeqa   #$02,SET_PLSD       ; Compare value in accumulator with decimal
                     1262                                   ; 2, if equal, branch to SET_PLSD:
 84AF [04] 410305    1263       cbeqa   #$03,SET_SMSD       ; Compare value in accumulator with decimal
                     1264                                   ; 3, if equal, branch to SET_PMSD:
 84B2 [05] 4E4A00    1265       mov     SLSDBCD,PORTA       ; Move value in Stbd Least Significant Digit
                     1266                                   ; BCD variable to Port A Data Register
 84B5 [03] 200D      1267       bra     DISP_SEQ_DONE       ; Branch to DISP_SEQ_DONE:
                     1268  
                     1269  SET_SMSD:
 84B7 [05] 4E4B00    1270       mov     SMSDBCD,PORTA       ; Move value in Stbd Most Significant Digit
                     1271                                   ; BCD variable to Port A Data Register
 84BA [03] 2008      1272       bra     DISP_SEQ_DONE       ; Branch to DISP_SEQ_DONE:
                     1273  
                     1274  SET_PLSD:
 84BC [05] 4E4C00    1275       mov     PLSDBCD,PORTA       ; Move value in Port Least Significant Digit
                     1276                                   ; BCD variable to Port A Data Register
 84BF [03] 2003      1277       bra     DISP_SEQ_DONE       ; Branch to DISP_SEQ_DONE:
                     1278  
                     1279  SET_PMSD:
 84C1 [05] 4E4D00    1280       mov     PMSDBCD,PORTA       ; Move value in Port Most Significant Digit
                     1281                                   ; BCD variable to Port A Data Registe
                     1282  DISP_SEQ_DONE:
 84C4 [04] 116E      1283       bclr   clk10,inputs         ; Clear "clk10" bit of "inputs" variable
                     1284  
                     1285  NO_DISP_PASS:
                     1286  
                     1287  ;****************************************************************************
                     1288  ; - Calculate the output compare values for Servo pulse widths.
                     1289  ;   This is done only once per Tim1 modulo rollover at 50 HZ, in the first
                     1290  ;   pass through the main loop after the TIM1OV_ISR Interrupt routine has
                     1291  ;   been completed.
                     1292  ;****************************************************************************
                     1293  
                     1294  ;****************************************************************************
                     1295  ; - The Hitec HS-311 servos operate at centre of travel with a 1500uS
                     1296  ;   pulse width signal, at a frequency of 50 HZ. Full right travel is at
                     1297  ;   1900uS, and full left travel is at 1100uS. TIM1 is set up as a modulo
                     1298  ;   count up 50 HZ timer (20mS period) with 1uS resolution, for servo signal
                     1299  ;   control timing. Channels 0 and 1 are set up for output compare,
                     1300  ;   pulsewidth control of servos. Servo Port on T1SC0 and Servo Stbd on T1SC1.
                     1301  ;
                     1302  ;   Position of the choke plate angles are proportional to the control pot
                     1303  ;   position, and it is necessary to "calibrate" the system when first placed
                     1304  ;   into service. The maximum pulse width of 1900uS and minimum pulse width of
                     1305  ;   1100uS results in a span of 800uS. These are the figures entered in the
                     1306  ;   max and min variables for each servo as a starting point. The
                     1307  ;   control pots are set to their mid point position, which should result in
                     1308  ;   choke angles being close to mid point if the mechanical installation was
                     1309  ;   correct. The pots are carefully move CCW until the choke plates are just
                     1310  ;   wide open. Using "Megatune" the servo output compare value is recorded
                     1311  ;   as the minimum pulse width value. The pots are then moved CW until the
                     1312  ;   plates are just closed. Using "Megatune" again, the servo output compare
                     1313  ;   value is recorded as the maximum pulse width value. These new figures
                     1314  ;   are now enterd in the appropriate variables. Span is calculated only
                     1315  ;   once, at each start up.
                     1316  ;   The pot position * span / 256 = servo position. Servo position
                     1317  ;   + minimum pulse width value = commanded position pulse width.
                     1318  ;
                     1319  ; - Method for Servo Stbd, Servo Port being similar, where:
                     1320  ;
                     1321  ;   PotSpos  = Control pot Stbd position, 8 bit ADC reading
                     1322  ;   SSpwMnH  = Servo S OC value at open choke Hi byte
                     1323  ;   SSpwMnL  = Servo S OC value at open choke Lo byte
                     1324  ;   SSpwMxH  = Servo S OC value at closed choke Hi byte
                     1325  ;   SSpwMxL  = Servo S OC value at closed choke Lo byte
                     1326  ;   SSpwSpnH = Servo S span Hi byte
                     1327  ;   SSpwSpnL = Servo S span Lo byte
                     1328  ;   SSmulH   = Servo S multiplicand Hi byte
                     1329  ;   SSmulM   = Servo S multiplicand Mid byte
                     1330  ;   SSmulL   = Servo S multiplicand Lo byte
                     1331  ;   SSposH   = Servo S commanded position Hi byte
                     1332  ;   SSposL   = Servo S commanded position Lo byte
                     1333  ;   SrvSpwH  = Servo S OC for commanded position Hi byte
                     1334  ;   SrvSpwL  = Servo S OC for commanded position Lo byte
                     1335  ;
                     1336  ;   SSpwMxH:SSpwMxL - SSpwMnH:SSpwMnL = SSpwSpnH:SSpwSpnL
                     1337  ;   (This calculation is done at start up after the flash constants are
                     1338  ;   loaded into RAM, and copied to direct page)
                     1339  ;
                     1340  ;   SSpwSpnH:SSpwSpnL * PotSpos = SSmulH:SSmulM:SSmulL
                     1341  ;
                     1342  ;   SSmulH:SSmulM:SSmulL / 256 = SSposH:SSposL
                     1343  ;
                     1344  ;   SSposH:SSposL + SSpwMnH:SSpwMnL = SrvSpwH:SrvSpwL
                     1345  ;
                     1346  ;****************************************************************************
                     1347  
                     1348  ;****************************************************************************
                     1349  ;
                     1350  ; ------------- UMUL32 16 x 16 Unsigned Multiply Subroutine -----------------
                     1351  ;
                     1352  ;     tmp8...tmp5 = tmp4:tmp3 * tmp2:tmp1
                     1353  ;
                     1354  ;               tmp3*tmp1
                     1355  ;   +      tmp4*tmp1
                     1356  ;   +      tmp3*tmp2
                     1357  ;   + tmp4*tmp2
                     1358  ;   = ===================
                     1359  ;     tmp8 tmp7 tmp6 tmp5


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 14
MC68HC908GP32 User Bootloader


                     1360  ;
                     1361  ;****************************************************************************
                     1362  
 84C6 [05] 046E03    1363       brset   pwp,inputs,PW_CALCS     ; If "pwp" bit of "inputs" variable
                     1364                                       ; is set, branch to PW_CALCS:
 84C9 [03] CC853A    1365       jmp     NO_PW_CALCS             ; Jump to NO_PW_CALCS:
                     1366  
                     1367  
                     1368  ;****************************************************************************
                     1369  ; - Calculate OC value for Servo S position. First, multiply the span by pot,
                     1370  ;   position.
                     1371  ;   SSpwSpnH:SSpwSpnL * PotSpos = SSmulH:SSmulM:SSmulL
                     1372  ;****************************************************************************
                     1373  
                     1374  PW_CALCS:
 84CC [05] 4E4277    1375       mov     PotSpos,tmp1      ; Copy value in "PotSpos" to tmp1
 84CF [03] 3F78      1376       clr     tmp2              ; Clear tmp2
 84D1 [05] 4E5379    1377       mov     SSpwSpnL,tmp3     ; Copy value in "SSpwSpnL" to tmp3
 84D4 [05] 4E527A    1378       mov     SSpwSpnH,tmp4     ; Copy value in "SSpwSpnL" to tmp3
 84D7 [05] CD8794    1379       jsr     UMUL32            ; Jump to subroutine at UMUL32:
                     1380                                 ;(Result in tmp7:tmp6:tmp5
 84DA [05] 4E7B56    1381       mov     tmp5,SSmulL       ; Copy value in tmp5 to "SSmulL"
 84DD [05] 4E7C55    1382       mov     tmp6,SSmulM       ; Copy value in tmp6 to "SSmulM"
 84E0 [05] 4E7D54    1383       mov     tmp7,SSmulH       ; Copy value in tmp7 to "SSmulH"
                     1384  
                     1385  ;****************************************************************************
                     1386  ; - Next, divide the product by 256. This is done by deleting the LSB, but
                     1387  ;   first, see if the quotient should be rounded up, as this method rounds
                     1388  ;   down.
                     1389  ;   SSmulH:SSmulM:SSmulL / 256 = SSposH:S0posL
                     1390  ;****************************************************************************
                     1391  
 84E3 [03] B656      1392       lda     SSmulL          ; Load accumulator with value in "SSmulL"
 84E5 [02] A180      1393       cmp     #$80            ; Compare value in accumulator with decimal 128
 84E7 [03] 9306      1394       ble     SS_RND_DONE     ; If A<=M, branch to SS_RND_DONE:
 84E9 [04] 3C55      1395       inc     SSmulM          ; Increment value in "SSmulM"
 84EB [03] 2402      1396       bcc     SS_RND_DONE     ; If carry bit is clear, branch to
                     1397                               ; SS_RND_DONE:
 84ED [04] 3C54      1398       inc     SSmulH          ; Increment value in "SSmulH"
                     1399  
                     1400  SS_RND_DONE:
 84EF [05] 4E5558    1401       mov     SSmulM,SSposL   ; Copy value in "SSmulM" to "SSposL"
 84F2 [05] 4E5457    1402       mov     SSmulH,SSposH   ; Copy value in "SSmulH" to "SSposH"
                     1403  
                     1404  ;****************************************************************************
                     1405  ; - Now, add the servo position variable with the pulse width minimum
                     1406  ;   variable to get the commanded pulse width value.
                     1407  ;   SSposH:SSposL + SSpwMnH:SSpwMnL = SrvSpwH:SrvSpwL
                     1408  ;****************************************************************************
                     1409  
 84F5 [03] B658      1410       lda     SSposL         ; Load accumulator with value in "SSposL"
 84F7 [03] BB4F      1411       add     SSpwMnL        ; Add without Carry A<-(A)+(M)
                     1412                              ;(SSposL + SSpwMnL)
 84F9 [01] 97        1413       tax                    ; Transfer result in accumulator to index
                     1414                              ; register Lo byte
 84FA [03] B657      1415       lda     SSposH         ; Load accumulator with value in "SSposH"
 84FC [03] B94E      1416       adc     SSpwMnH        ; Add with Carry A<-(A)+(M)
                     1417                              ;(SSposH + SSpwMnH)
 84FE [03] B759      1418       sta     SrvSpwH        ; Copy to Servo S O/C value Hi byte
 8500 [03] BF5A      1419       stx     SrvSpwL        ; Copy to Servo S O/C value Lo byte
                     1420  
                     1421  ;****************************************************************************
                     1422  ; - Calculate OC value for Servo P position. First, multiply the span by pot,
                     1423  ;   position.
                     1424  ;   SPpwSpnH:SPpwSpnL * PotPpos = SPmulH:SPmulM:SPmulL
                     1425  ;****************************************************************************
                     1426  
 8502 [05] 4E4377    1427       mov     PotPpos,tmp1      ; Copy value in "PotPpos" to tmp1
 8505 [03] 3F78      1428       clr     tmp2              ; Clear tmp2
 8507 [05] 4E6079    1429       mov     SPpwSpnL,tmp3     ; Copy value in "SPpwSpnL" to tmp3
 850A [05] 4E5F7A    1430       mov     SPpwSpnH,tmp4     ; Copy value in "SPpwSpnL" to tmp3
 850D [05] CD8794    1431       jsr     UMUL32            ; Jump to subroutine at UMUL32:
                     1432                                 ;(Result in tmp7:tmp6:tmp5
 8510 [05] 4E7B63    1433       mov     tmp5,SPmulL       ; Copy value in tmp5 to "SPmulL"
 8513 [05] 4E7C62    1434       mov     tmp6,SPmulM       ; Copy value in tmp6 to "SPmulM"
 8516 [05] 4E7D61    1435       mov     tmp7,SPmulH       ; Copy value in tmp7 to "SPmulH"
                     1436  
                     1437  ;****************************************************************************
                     1438  ; - Next, divide the product by 256. This is done by deleting the LSB, but
                     1439  ;   first, see if the quotient should be rounded up, as this method rounds
                     1440  ;   down.
                     1441  ;   SPmulH:SPmulM:SPmulL / 256 = SPposH:SPposL
                     1442  ;****************************************************************************
                     1443  
 8519 [03] B663      1444       lda     SPmulL          ; Load accumulator with value in "SPmulL"
 851B [02] A180      1445       cmp     #$80            ; Compare value in accumulator with decimal 128
 851D [03] 9306      1446       ble     SP_RND_DONE     ; If A<=M, branch to SP_RND_DONE:
 851F [04] 3C62      1447       inc     SPmulM          ; Increment value in "SPmulM"
 8521 [03] 2402      1448       bcc     SP_RND_DONE     ; If carry bit is clear, branch to
                     1449                               ; SP_RND_DONE:
 8523 [04] 3C61      1450       inc     SPmulH          ; Increment value in "SPmulH"
                     1451  
                     1452  SP_RND_DONE:
 8525 [05] 4E6265    1453       mov     SPmulM,SPposL   ; Copy value in "SPmulM" to "SPposL"
 8528 [05] 4E6164    1454       mov     SPmulH,SPposH   ; Copy value in "SPmulH" to "SPposH"
                     1455  
                     1456  ;****************************************************************************
                     1457  ; - Now, add the servo position variable with the pulse width minimum
                     1458  ;   variable to get the commanded pulse width value.
                     1459  ;   SPposH:SPposL + SPpwMnH:SPpwMnL = SrvPpwH:SrvPpwL
                     1460  ;****************************************************************************
                     1461  
 852B [03] B665      1462       lda     SPposL         ; Load accumulator with value in "SPposL"
 852D [03] BB5C      1463       add     SPpwMnL        ; Add without Carry A<-(A)+(M)
                     1464                              ;(SPposL + SPpwMnL)
 852F [01] 97        1465       tax                    ; Transfer result in accumulator to index
                     1466                              ; register Lo byte
 8530 [03] B664      1467       lda     SPposH         ; Load accumulator with value in "SPposH"
 8532 [03] B95B      1468       adc     SPpwMnH        ; Add with Carry A<-(A)+(M)
                     1469                              ;(SPposH + SPpwMnH)
 8534 [03] B766      1470       sta     SrvPpwH        ; Copy to Servo P O/C value Hi byte
 8536 [03] BF67      1471       stx     SrvPpwL        ; Copy to Servo P O/C value Lo byte
 8538 [04] 156E      1472       bclr    pwp,inputs     ; Clear "pwp" bit of "inputs" variable
                     1473  
                     1474  NO_PW_CALCS:
                     1475  
                     1476  LOOP_END:
 853A [03] CC83F9    1477       jmp     LOOPER    ; Jump to LOOPER: (End of Main Loop!!!)
                     1478  
                     1479  
                     1480  ;****************************************************************************
                     1481  ;
                     1482  ; * * * * * * * * * * * * * * Interrupt Section * * * * * * * * * * * * * *
                     1483  ;
                     1484  ; NOTE!!! If the interrupt service routine modifies the H register, or uses
                     1485  ; the indexed addressing mode, save the H register (pshh) and then restore
                     1486  ; it (pulh) prior to exiting the routine
                     1487  ;
                     1488  ;****************************************************************************
                     1489  
                     1490  ;****************************************************************************
                     1491  ;
                     1492  ; -------- Following interrupt service routines in priority order ----------
                     1493  ;
                     1494  ;
                     1495  ; TIM1OV_ISR:  - TIM1 Overflow ($4E20 * 1uS) 20mS (50 HZ) servo period


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 15
MC68HC908GP32 User Bootloader


                     1496  ;
                     1497  ; TIM2CH0_ISR: - TIM2 CH0 output compare ($0064 * 1uS) (100us Timer Tick)
                     1498  ;
                     1499  ; SCIRCV_ISR:  - SCI receive
                     1500  ;
                     1501  ; SCITX_ISR:   - SCI transmit
                     1502  ;
                     1503  ; ADC_ISR:     - ADC Conversion Complete
                     1504  ;
                     1505  ;****************************************************************************
                     1506  
                     1507  ;****************************************************************************
                     1508  ;============================================================================
                     1509  ; - TIM1 Overflow interrupt (50 HZ servo period)
                     1510  ;   Stop and clear timer
                     1511  ;   Load 50 HZ modulo to T1SC
                     1512  ;   Load new pulse width values to channel registers
                     1513  ;   Enable overflow interrupts and restart timer
                     1514  ;============================================================================
                     1515  ;****************************************************************************
                     1516  
                     1517  TIM1OV_ISR:
 853D [04] 146E      1518       bset     pwp,inputs     ; Set "pwp" bit of "inputs" variable
 853F [02] 8B        1519       pshh                    ; Push index register Hi byte on to stack
 8540 [04] 6E3320    1520       mov     #$33,T1SC       ; Move %00110011 into Timer1
                     1521                               ; Status and Control Register
                     1522                               ;(Disable interrupts, stop timer)
                     1523                               ;(Prescale and counter cleared))
                     1524                               ;(Prescale for bus frequency / 8)
 8543 [04] 6E4E23    1525       mov     #$4E,T1MODH     ; Move decimal 78 into T1 modulo reg Hi
 8546 [04] 6E2024    1526       mov     #$20,T1MODL     ; Move decimal 32 into T1 modulo reg Lo
 8549 [05] 4E6626    1527       mov     SrvPpwH,T1CH0H  ; Move value in SrvPpwH to T1CH0 register Hi
                     1528                               ; byte (servo P OC hy byte)
 854C [05] 4E6727    1529       mov     SrvPpwL,T1CH0L  ; Move value in SrvPpwL to T1CH0 register Lo
                     1530                               ; byte (servo P OC lo byte)
 854F [05] 4E5929    1531       mov     SrvSpwH,T1CH1H  ; Move value in SrvSpwH to T1CH1 register Hi
                     1532                               ; byte (servo S OC hy byte)
 8552 [05] 4E5A2A    1533       mov     SrvSpwL,T1CH1L  ; Move value in SrvSpwL to T1CH1 register Lo
                     1534                               ; byte (servo S OC lo byte)
 8555 [04] 6E4320    1535       mov     #$43,T1SC       ; Move %01000011 into Timer1
                     1536                               ; Status and Control Register
                     1537                               ; Enable overflow interrupts, counter active
                     1538                               ; Prescale for bus frequency / 8
                     1539                               ; 8,003584hz/8=1000448hz
                     1540                               ; = .0000009995sec
 8558 [02] 8A        1541       pulh                    ; Pull value from stack to index register
                     1542                               ; Hi byte
 8559 [07] 80        1543       rti                     ; Return from interrupt
                     1544  
                     1545  
                     1546  ;****************************************************************************
                     1547  ;============================================================================
                     1548  ; - TIM2 CH0 Interrupt (100 uS clock tick)
                     1549  ; - Generate time rates:
                     1550  ;   100 Microseconds,(just to get things started)
                     1551  ;   1 Millisecond,(for ADC conversions)
                     1552  ;   10 Milliseconds,(100hz clock tick for display alternation)
                     1553  ;   Seconds,(because we can)
                     1554  ;============================================================================
                     1555  ;****************************************************************************
                     1556  
                     1557  TIM2CH0_ISR:
 855A [02] 8B        1558       pshh                  ; Push value in index register Hi byte to stack
 855B [03] B630      1559       lda     T2SC0         ; Load accumulator with value in TIM2 CH0 Status
                     1560                             ; and Control Register (Arm CHxF flag clear)
 855D [04] 1F30      1561       bclr    CHxF,T2SC0    ; Clear CHxF bit of TIM2 CH0 Status and
                     1562                             ; Control Register
 855F [04] 5531      1563       ldhx    T2CH0H        ; Load index register with value in TIM2 CH0
                     1564                             ; register H:L (output compare value)
 8561 [02] AF64      1565       aix     #$64          ; Add decimal 100 (100 uS)
 8563 [04] 3531      1566       sthx    T2CH0H        ; Copy result to TIM2 CH0 register
                     1567                             ;(new output compare value)
                     1568  
                     1569  
                     1570  ;============================================================================
                     1571  ;********************** 100 Microsecond section *****************************
                     1572  ;============================================================================
                     1573  
                     1574  ;****************************************************************************
                     1575  ; - Increment 100 Microsecond counter
                     1576  ;****************************************************************************
                     1577  
                     1578  INC_cuS:
 8565 [04] 3C68      1579       inc     uSx100               ; Increment 100 uS counter
 8567 [03] B668      1580       lda     uSx100               ; Load accumulator with 100 uS counter
 8569 [02] A10A      1581       cmp     #$0A                 ; Compare it with decimal 10
 856B [03] 2703      1582       beq     FIRE_ADC             ; If Z bit of CCR is set, branch to
                     1583                                    ; FIRE_ADC:(uSx100 = 10)
 856D [03] CC85A6    1584       jmp     TIM2CH0_ISR_DONE     ; Jump to TIM2CH0_ISR_DONE:
                     1585  
                     1586  ;============================================================================
                     1587  ;************************* millisecond section ******************************
                     1588  ;============================================================================
                     1589  
                     1590  ;****************************************************************************
                     1591  ; - Fire off another ADC conversion, channel is pointed to by "adsel"
                     1592  ;****************************************************************************
                     1593  
                     1594  FIRE_ADC:
 8570 [03] B66D      1595       lda     adsel          ; Load accumulator with ADC Selector Variable
 8572 [02] AA40      1596       ora     #%01000000     ; Inclusive "or" with %01000000 and ADC Selector
                     1597                              ; Variable ( result in accumulator )
                     1598                              ;(Enables interupt with channel selected)
 8574 [03] B73C      1599       sta     ADSCR          ; Copy result to ADC Status and Control Register
                     1600  
                     1601  ;****************************************************************************
                     1602  ; - Increment millisecond counter
                     1603  ;****************************************************************************
                     1604  
                     1605  INC_mS:
 8576 [03] 3F68      1606       clr     uSx100              ; Clear 100 Microsecond counter
 8578 [04] 3C69      1607       inc     mS                  ; Increment Millisecond counter
 857A [03] B669      1608       lda     mS                  ; Load accumulator with value in
                     1609                                   ; Millisecond counter
 857C [02] A10A      1610       cmp     #$0A                ; Compare it with decimal 10
 857E [03] 2703      1611       beq     DO_100HZ            ; If Z bit of CCR is set, branch to
                     1612                                   ; DO_100HZ:(mS = 10)
 8580 [03] CC85A6    1613       jmp     TIM2CH0_ISR_DONE    ; Jump to TIM2CH0_ISR_DONE:
                     1614  
                     1615  ;============================================================================
                     1616  ;************************** 10 Millisecond section **************************
                     1617  ;============================================================================
                     1618  
                     1619  ;****************************************************************************
                     1620  ; - Increment display sequencing counter
                     1621  ;****************************************************************************
                     1622  
                     1623  DO_100HZ:
 8583 [04] 106E      1624       bset    clk10,inputs     ; Set "clk10" bit of "inputs" variable
 8585 [03] B697      1625       lda     dsel             ; Load accumulator with value in "dsel"
 8587 [02] A103      1626       cmp     #$03             ; compare with decimal 3
 8589 [03] 2404      1627       bhs     ROLL_DIS         ; If A>=decimal 3, branch to ROLL_DIS:
 858B [04] 3C97      1628       inc     dsel             ; Increment "dsel"
 858D [03] 2002      1629       bra     INC_MSx10        ; Branch to INC_MSx10:
                     1630  
                     1631  ROLL_DIS:


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 16
MC68HC908GP32 User Bootloader


 858F [03] 3F97      1632       clr     dsel             ; Clear "dsel"
                     1633  
                     1634  ;****************************************************************************
                     1635  ; - Increment 10 millisecond counter
                     1636  ;****************************************************************************
                     1637  
                     1638  INC_MSx10:
 8591 [03] 3F69      1639       clr     mS                  ; Clear Millisecond counter
 8593 [04] 3C6A      1640       inc     mSx10               ; Increment 10 Millisecond counter
 8595 [03] B66A      1641       lda     mSx10               ; Load accumulator with value in
                     1642                                   ; 10 Millisecond counter
 8597 [02] A164      1643       cmp     #$64                ; Compare it with decimal 100
 8599 [03] 2703      1644       beq     INC_S               ; If Z bit of CCR is set, branch to
                     1645                                   ; INC_S:(mSx10 x 100 = 1000mS = 1Sec)
 859B [03] CC85A6    1646       jmp     TIM2CH0_ISR_DONE    ; Jump to TIM2CH0_ISR_DONE:
                     1647  
                     1648  
                     1649  ;============================================================================
                     1650  ;**************************** Seconds section *******************************
                     1651  ;============================================================================
                     1652  
                     1653  ;****************************************************************************
                     1654  ; - Increment seconds counter
                     1655  ;****************************************************************************
                     1656  
                     1657  INC_S:
 859E [03] 3F6A      1658       clr     mSx10               ; Clear 10 Millisecond counter
 85A0 [04] 3C41      1659       inc     secl                ; Increment "Seconds" Lo byte variable
 85A2 [03] 2602      1660       bne     TIM2CH0_ISR_DONE    ; If the Z bit of CCR is clear, branch
                     1661                                   ; to TIM2CH0_ISR_DONE:
 85A4 [04] 3C40      1662       inc     sech                ; Increment "Seconds" Hi byte variable
                     1663  
                     1664  TIM2CH0_ISR_DONE:
 85A6 [02] 8A        1665       pulh                  ; Pull value from stack to index register Hi byte
 85A7 [07] 80        1666       rti                   ; Return from interrupt
                     1667  
                     1668  ;****************************************************************************
                     1669  ;
                     1670  ; -------------------- Serial Communications Interface ----------------------
                     1671  ;
                     1672  ; Communications is established when the PC communications program sends
                     1673  ; a command character - the particular character sets the mode:
                     1674  ;
                     1675  ; "A" = send all of the realtime variables via txport.
                     1676  ; "V" = send the Constants via txport (64 bytes)
                     1677  ; "W"+<offset>+<newbyte> = receive new constant byte value and store in
                     1678  ;       offset location
                     1679  ;;; "V" = send the Constants group 1 via txport (128 bytes)
                     1680  ;;;       (TO_table, RPM_range, KPA_range, TPS_range, EPC_stall, EPC_12,
                     1681  ;;;        EPC_23, EPC_34, tables, + 8 spares)
                     1682  ;;; "W"+<offset>+<newbyte> = receive new table byte value and store in
                     1683  ;;;       offset location
                     1684  ; "B" = jump to flash burner routine and all constant values in
                     1685  ;       RAM into flash
                     1686  ; "C" = Test communications - echo back SECL
                     1687  ; "Q" = Send over Embedded Code Revision Number (divide number by 10
                     1688  ;  - i.e. $21T is rev 2.1)
                     1689  ;;; "I" = send the Constants group 2 via txport (64 bytes)
                     1690  ;;; "J"+<offset>+<newbyte> =receive new table byte value and store in
                     1691  ;       offset location
                     1692  ;
                     1693  ; txmode:
                     1694  ;              01 = Getting realtime data
                     1695  ;              02 = ?
                     1696  ;              03 = Sending G1
                     1697  ;              04 = ?
                     1698  ;              05 = Getting offset G1
                     1699  ;              06 = Getting data G1
                     1700  ;;;              07 = Getting offset G2
                     1701  ;;;              08 = Getting data G2
                     1702  ;;;              09 = Sending G2
                     1703  ;
                     1704  ;***************************************************************************
                     1705  
                     1706  SCIRCV_ISR:
 85A8 [02] 8B        1707       pshh                 ; Push value in index register Hi byte to Stack
 85A9 [03] B616      1708       lda     SCS1         ; Load accumulator with value in "SCS1"
                     1709                            ;(Clear the SCRF bit by reading this register)
 85AB [03] B68F      1710       lda     txmode       ; Load accumulator with value in "txmode" variable
                     1711                            ;(Check if we are in the middle of a receive
                     1712                            ; new VE/constant)
 85AD [02] A105      1713       cmp     #$05         ; Compare with decimal 5
 85AF [03] 2706      1714       beq     TXMODE_5     ; If the Z bit of CCR is set, branch to TXMODE_5:
 85B1 [02] A106      1715       cmp     #$06         ; Compare with decimal 6
 85B3 [03] 270A      1716       beq     TXMODE_6     ; If the Z bit of CCR is set, branch to TXMODE_6:
                     1717  ;;;     cmp     #$07         ; Compare with decimal 7
                     1718  ;;;     beq     TXMODE_7     ; If the Z bit of CCR is set, branch to TXMODE_7:
                     1719  ;;;     cmp     #$08         ; Compare with decimal 8
                     1720  ;;;     beq     TXMODE_8     ; If the Z bit of CCR is set, branch to TXMODE_8:
 85B5 [03] 2015      1721       bra     CHECK_TXCMD  ; Branch to CHECK_TXCMD:
                     1722  
                     1723  TXMODE_5:                 ; (Getting offset for either W or J command)
                     1724  
                     1725  ;;;TXMODE_7:
 85B7 [05] 4E1890    1726       mov     SCDR,rxoffset   ; Move value in "SCDR" to "rxoffset"
 85BA [04] 3C8F      1727       inc     txmode          ; (continue to next mode)
 85BC [03] CC8633    1728       jmp     DONE_RCV        ; Jump to DONE_RCV:
                     1729  
                     1730  TXMODE_6:
 85BF [01] 8C        1731       clrh                 ; Clear index register Hi byte
 85C0 [03] B690      1732       lda     rxoffset     ; Load accumulator with value in "rxoffset"
 85C2 [01] 97        1733       tax                  ; Transfer value in accumulator to index register
                     1734                            ; Lo byte
 85C3 [03] B618      1735       lda     SCDR         ; Load accumulator with value in "SCDR"
                     1736  ;;;     sta     TO_table,x   ; Copy to TO_table, offset in index register Lo byte
                     1737  ;;;                          ;(Write data to TO_table + offset)
 85C5 [03] E7A0      1738       sta     SSpwMnH_F,x   ; Copy to SSpwMnH_F, offset in index register Lo byte
                     1739                            ;(Write data to SSpwMnH_F + offset)
 85C7 [03] 3F8F      1740       clr     txmode       ; Clear "txmode" variable
 85C9 [03] CC8633    1741       jmp     DONE_RCV     ; Jump to DONE_RCV:
                     1742  
                     1743  ;;;TXMODE_8:
                     1744  ;;;     clrh                 ; Clear index register Hi byte
                     1745  ;;;     lda     rxoffset     ; Load accumulator with value in "rxoffset"
                     1746  ;;;                          ; (Get offset for data to be written)
                     1747  ;;;     tax                  ; Transfer value in accumulator to index register
                     1748  ;;;                          ; Lo byte
                     1749  ;;;     lda     SCDR         ; Load accumulator with value in "SCDR"
                     1750  ;;;     sta     EPC_TCC,x    ; Copy to EPC_TCC, offset in index register Lo byte
                     1751  ;;;                          ;(Write data to EPC_TCC + offset)
                     1752  ;;;     clr     txmode       ; Clear "txmode" variable
                     1753  ;;;     jmp     DONE_RCV     ; Jump to DONE_RCV:
                     1754  
                     1755  CHECK_TXCMD:
 85CC [03] B618      1756       lda     SCDR       ; Load accumulator with value in "SCDR"
                     1757                          ;(Get the command byte)
 85CE [02] A141      1758       cmp     #$41       ; Compare it with decimal 65 = ASCII "A"
                     1759                          ;(Is the recieve character a big "A" ->
                     1760                          ; Download real-time variables?)
 85D0 [03] 2714      1761       beq     MODE_A     ; If the Z bit of CCR is set, branch to Mode_A:
 85D2 [02] A142      1762       cmp     #$42       ; Compare it with decimal 66 = ASCII "B"
 85D4 [03] 2720      1763       beq     MODE_B     ; If the Z bit of CCR is set, branch to Mode_B:
 85D6 [02] A143      1764       cmp     #$43       ; Compare it with decimal 67 = ASCII "C"
 85D8 [03] 2723      1765       beq     MODE_C     ; If the Z bit of CCR is set, branch to Mode_C:
 85DA [02] A156      1766       cmp     #$56       ; Compare it with decimal 86 = ASCII "V"
 85DC [03] 272F      1767       beq     MODE_V     ; If the Z bit of CCR is set, branch to Mode_V:


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 17
MC68HC908GP32 User Bootloader


 85DE [02] A157      1768       cmp     #$57       ; Compare it with decimal 87 = ASCII "W"
 85E0 [03] 273B      1769       beq     MODE_W     ; If the Z bit of CCR is set, branch to Mode_W:
 85E2 [02] A151      1770       cmp     #$51       ; Compare it with decimal 81 = ASCII "Q"
 85E4 [03] 273D      1771       beq     MODE_Q     ; If the Z bit of CCR is set, branch to Mode_Q:
                     1772  ;;;     cmp     #'I'       ; Compare it with 'I' = ASCII decimal 73 $49
                     1773  ;;;     beq     MODE_I     ; If the Z bit of CCR is set, branch to Mode_I:
                     1774  ;;;     cmp     #'J'       ; Compare it with 'J' = ASCII decimal74 $4A
                     1775  ;;;     beq     MODE_J     ; If the Z bit of CCR is set, branch to Mode_J:
                     1776  ;;;     bra     DONE_RCV   ; Branch to DONE_RCV:
                     1777  
                     1778  MODE_A
 85E6 [03] 3F8D      1779       clr     txcnt          ; Clear "txcnt"
 85E8 [02] A601      1780       lda     #$01           ; Load accumulator with decimal 1
 85EA [03] B78F      1781       sta     txmode         ; Copy to "txmode" variable
 85EC [02] A629      1782       lda     #$29           ; Load accumulator with decimal 41
                     1783                              ;(Set this for 1 more than the number of bytes
                     1784                              ; to send)
                     1785                              ; Show all variables(for Megachat)
 85EE [03] B78E      1786       sta     txgoal         ; Copy to "txgoal" variable
 85F0 [04] 1614      1787       bset    TE,SCC2        ; Set "TE" bit of SCC2 (Enable Transmit)
 85F2 [04] 1E14      1788       bset    SCTIE,SCC2     ; Set "SCTIE" bit of SCC2
                     1789                              ;(Enable transmit interrupt)
 85F4 [03] 203D      1790       bra     DONE_RCV       ; Branch to DONE_RCV:
                     1791  
                     1792  MODE_B:
 85F6 [05] CD87F6    1793       jsr     burnConst     ; Jump to "burnConst" subroutine
 85F9 [03] 3F8F      1794       clr     txmode        ; Clear "txmode" variable
 85FB [03] 2036      1795       bra     DONE_RCV      ; Branch to DONE_RCV:
                     1796  
                     1797  MODE_C:
 85FD [03] 3F8D      1798       clr     txcnt          ; Clear "txcnt"
                     1799                              ; (Just send back SECL variable to test comm port)
 85FF [02] A601      1800       lda     #$01           ; Load accumulator with decimal 1
 8601 [03] B78F      1801       sta     txmode         ; Copy to "txmode" variable
 8603 [02] A602      1802       lda     #$2            ; Load accumulator with decimal 2
 8605 [03] B78E      1803       sta     txgoal         ; Copy to "txgoal" variable
 8607 [04] 1614      1804       bset    TE,SCC2        ; Set "TE" bit of SCC2 (Enable Transmit)
 8609 [04] 1E14      1805       bset    SCTIE,SCC2     ; Set "SCTIE" bit of SCC2
                     1806                              ;(Enable transmit interrupt)
 860B [03] 2026      1807       bra     DONE_RCV       ; Branch to DONE_RCV:
                     1808  
                     1809  MODE_V:
 860D [03] 3F8D      1810       clr     txcnt          ; Clear "txcnt"
 860F [02] A603      1811       lda     #$03           ; Load accumulator with decimal 3
 8611 [03] B78F      1812       sta     txmode         ; Copy to "txmode" variable
 8613 [02] A681      1813       lda     #$81           ; Load accumulator with decimal 129
                     1814                              ;(Set this for 1 more than the number of bytes
                     1815                              ; to send)
                     1816                              ;(Send 128 bytes, TO table, ranges, EPC stall
                     1817                              ; and shift tables + spares)
 8615 [03] B78E      1818       sta     txgoal         ; Copy to "txgoal" variable
 8617 [04] 1614      1819       bset    TE,SCC2        ; Set "TE" bit of SCC2 (Enable Transmit)
 8619 [04] 1E14      1820       bset    SCTIE,SCC2     ; Set "SCTIE" bit of SCC2
                     1821                              ;(Enable transmit interrupt)
 861B [03] 2016      1822       bra     DONE_RCV       ; Branch to DONE_RCV:
                     1823  
                     1824  MODE_W:
 861D [02] A605      1825       lda     #$05         ; Load accumulator with decimal 5
 861F [03] B78F      1826       sta     txmode       ; Copy to "txmode" variable
 8621 [03] 2010      1827       bra     DONE_RCV     ; Branch to DONE_RCV:
                     1828  
                     1829  MODE_Q:
 8623 [03] 3F8D      1830       clr     txcnt          ; Clear "txcnt"
                     1831                              ; (Just send back SECL variable to test comm port)
 8625 [02] A605      1832       lda     #$05           ; Load accumulator with decimal 5
 8627 [03] B78F      1833       sta     txmode         ; Copy to "txmode" variable
 8629 [02] A602      1834       lda     #$2            ; Load accumulator with decimal 2
 862B [03] B78E      1835       sta     txgoal         ; Copy to "txgoal" variable
 862D [04] 1614      1836       bset    TE,SCC2        ; Set "TE" bit of SCC2 (Enable Transmit)
 862F [04] 1E14      1837       bset    SCTIE,SCC2     ; Set "SCTIE" bit of SCC2
                     1838                              ;(Enable transmit interrupt)
 8631 [03] 2000      1839       bra     DONE_RCV       ; Branch to DONE_RCV:
                     1840  
                     1841  ;;;MODE_I:
                     1842  ;;;     clr     txcnt          ; Clear "txcnt"
                     1843  ;;;     lda     #$09           ; Load accumulator with decimal 9
                     1844  ;;;                            ; (txmode = sending Cons Group 2)
                     1845  ;;;     sta     txmode         ; Copy to "txmode" variable
                     1846  ;;;     lda     #$41           ; Load accumulator with decimal 65
                     1847  ;;;                            ;(Set this for 1 more than the number of bytes
                     1848  ;;;                            ; to send)
                     1849  ;;;                            ;(Send 64 bytes, constants + spares)
                     1850  ;;;     sta     txgoal         ; Copy to "txgoal" variable
                     1851  ;;;     bset    TE,SCC2        ; Set "TE" bit of SCC2 (Enable Transmit)
                     1852  ;;;     bset    SCTIE,SCC2     ; Set "SCTIE" bit of SCC2
                     1853  ;;;                            ;(Enable transmit interrupt)
                     1854  ;;;     bra     DONE_RCV       ; Branch to DONE_RCV:
                     1855  
                     1856  ;;;MODE_J:
                     1857  ;;;     lda     #$07         ; Load accumulator with decimal 7
                     1858  ;;;                          ; (txmode = getting offset Cons group 2)
                     1859  ;;;     sta     txmode       ; Copy to "txmode" variable
                     1860  
                     1861  DONE_RCV
 8633 [02] 8A        1862       pulh                 ; Pull value from Stack to index register Hi byte
 8634 [07] 80        1863       rti                  ; Return from interrupt
                     1864  
                     1865  ;****************************************************************************
                     1866  ;----------------- Transmit Character Interrupt Handler --------------------
                     1867  ;****************************************************************************
                     1868  
                     1869  SCITX_ISR:
 8635 [02] 8B        1870       pshh                  ; Push value in index register Hi byte to Stack
 8636 [03] B616      1871       lda     SCS1          ; Load accumulator with value in "SCS1"
                     1872                             ; (Clear the SCRF bit by reading this register)
 8638 [01] 8C        1873       clrh                  ; Clear index register Hi byte
 8639 [03] B68D      1874       lda     txcnt         ; Load accumulator with value in "txcnt" variable
 863B [01] 97        1875       tax                   ; Transfer value in accumulator to index register
                     1876                             ; Lo byte
 863C [03] B68F      1877       lda     txmode        ; Load accumulator with value in "txmode" variable
 863E [02] A105      1878       cmp     #$05          ; Compare it with decimal 5
 8640 [03] 270C      1879       beq     IN_Q_MODE     ; If the Z bit of CCR is set, branch to IN_Q_MODE:
                     1880  ;;     cmp     #$09          ; Compare it with decimal 9
                     1881  ;;     beq     IN_I_MODE     ; If the Z bit of CCR is set, branch to IN_I_MODE:
 8642 [02] A101      1882       cmp     #$01          ; Compare it with decimal 1
 8644 [03] 2604      1883       bne     IN_V_MODE     ; If the Z bit of CCR is clear, branch to IN_V_MODE:
                     1884  
                     1885  IN_A_OR_C_MODE:
 8646 [03] E640      1886       lda     secH,X        ; Load accumulator with value in address "secH",
                     1887                             ; offset in index register Lo byte
 8648 [03] 2007      1888       bra     CONT_TX       ; Branch to CONT_TX:
                     1889  
                     1890  IN_V_MODE
 864A [03] E6A0      1891       lda     SSpwMnH_F,x   ; Load accumulator with value in address
                     1892                             ; "SSpwMnH_F", offset in index register Lo byte
 864C [03] 2003      1893       bra     CONT_TX       ; Branch to CONT_TX:
                     1894  
                     1895  ;;IN_I_MODE
                     1896  ;;     lda     EPC_TCC,x   ; Load accumulator with value in address "EPC_TCC",
                     1897  ;;                         ; offset in index register Lo byte
                     1898  ;;    bra     CONT_TX     ; Branch to CONT_TX:
                     1899  
                     1900  IN_Q_MODE
 864E [04] D6E000    1901       lda     REVNUM,X   ; Load accumulator with value in address "REVNUM",
                     1902                          ; offset in index register Lo byte
                     1903  


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 18
MC68HC908GP32 User Bootloader


                     1904  CONT_TX:
 8651 [03] B718      1905       sta     SCDR           ; Copy to "SCDR" variable (Send char)
 8653 [03] B68D      1906       lda     txcnt          ; Load accumulator with value in "txcnt" variable
 8655 [01] 4C        1907       inca                   ; Increment value in accumulator
                     1908                              ;(Increase number of chars sent)
 8656 [03] B78D      1909       sta     txcnt          ; Copy to "txcnt" variable
 8658 [03] B18E      1910       cmp     txgoal         ; Compare it to value in "txgoal" (Check if done)
 865A [03] 260A      1911       bne     DONE_XFER      ; If the Z bit of CCR is clear, branch to DONE_XFER:
                     1912                              ;(Branch if NOT done to DONE_XFER !?!?!)
 865C [03] 3F8D      1913       clr     txcnt          ; Clear "txcnt"
 865E [03] 3F8E      1914       clr     txgoal         ; Clear "txgoal"
 8660 [03] 3F8F      1915       clr     txmode         ; Clear "txmode"
 8662 [04] 1714      1916       bclr    TE,SCC2        ; Clear "TE" bit of SCC2 (Disable Transmit)
 8664 [04] 1F14      1917       bclr    SCTIE,SCC2     ; Clear "SCTIE" bit of SCC2
                     1918                              ;(Disable transmit interrupt)
                     1919  
                     1920  DONE_XFER
 8666 [02] 8A        1921       pulh                   ; Pull value from Stack to index register Hi byte
 8667 [07] 80        1922       rti                    ; Return from interrupt
                     1923  
                     1924  
                     1925  ;****************************************************************************
                     1926  ; - ADC conversion complete Interrupt
                     1927  ;   ADC channel is set by "adsel" variable which starts at 2. This reads
                     1928  ;   channel 2, which is "PotSpos". When the conversion complete interrupt is
                     1929  ;   requested the current value in "PotSpos" is averaged with the result of
                     1930  ;   the ADC in the ADC Data Register (ADR) and stored as current "PotSpos"
                     1931  ;   This is to smooth out ADC "jitter". The "adsel" variable is then
                     1932  ;   incremented to the next channel and the process repeats until the 3
                     1933  ;   channels are read, at which time, "adsel" is set at 2 to start the
                     1934  ;   sequence again.
                     1935  ;****************************************************************************
                     1936  
                     1937  
                     1938  ADC_ISR:
 8668 [04] 126E      1939       bset    adcc,inputs  ; Set "adcc" bit of "inputs" variable
 866A [02] 8B        1940       pshh              ; Push index register Hi byte on to stack
                     1941                         ;(Do this because processor does not stack H)
 866B [01] 8C        1942       clrh              ; Clear index register Hi byte
 866C [03] B66D      1943       lda     adsel     ; Load accumulator with value in ADC Channel Selector
 866E [01] 97        1944       tax               ; Transfer value in accumulator to index register Lo
 866F [03] B63D      1945       lda     ADR       ; Load accumulator with value in ADC Data Register
                     1946                         ;(this also clears conversion complete and
                     1947                         ; interrupt enable bit)
 8671 [03] EB42      1948       add     PotSpos,x ; Add ADR and PotSpos,x (Add the two values)
 8673 [01] 46        1949       rora              ; Rotate right through carry (Divide by 2)
 8674 [03] E742      1950       sta     PotSpos,x ; Copy result to address PotSpos,x
 8676 [03] B66D      1951       lda     adsel     ; Load accumulator with value in ADC Channel Selector
 8678 [01] 4C        1952       inca              ; Increment ADC Channel Selector Variable
 8679 [02] A104      1953       cmp     #$04      ; Compare value in accumulator with decimal 4
 867B [03] 2202      1954       bhi     ROLL_ADC  ; If A>4 branch to ROLL_ADC:
 867D [03] 2002      1955       bra     NEW_ADC   ; Branch to NEW_ADC:
                     1956  
                     1957  ROLL_ADC:
 867F [02] A602      1958       lda     #$02         ; Load accumulator with decimal 2
                     1959  
                     1960  NEW_ADC:
 8681 [03] B76D      1961       sta     adsel        ; Copy new value to ADC Channel Selector Variable
 8683 [02] 8A        1962       pulh                 ; Pull value from stack to index register Hi byte
 8684 [07] 80        1963       rti                  ; Return from interrupt
                     1964  
                     1965  
                     1966  ;**************************************************************************
                     1967  ;==========================================================================
                     1968  ;- Dummy ISR vector - there just to keep the assembler happy
                     1969  ;==========================================================================
                     1970  ;**************************************************************************
                     1971  
                     1972  Dummy:
 8685 [07] 80        1973       rti     ; Return from interrupt
                     1974  
                     1975  ;***************************************************************************
                     1976  ;
                     1977  ; ---------------------------- SUBROUTINES --------------------------------
                     1978  ;
                     1979  ;  - Ordered Table Search routine
                     1980  ;  - Linear Interpolation routine
                     1981  ;  - 32 x 16 divide routine
                     1982  ;  - Round after division routine
                     1983  ;  - 16 x 16 multiply routine
                     1984  ;  - 8 x 16 multiply and 16 by 100 divide
                     1985  ;
                     1986  ;***************************************************************************
                     1987  
                     1988  
                     1989  ;***************************************************************************
                     1990  ;
                     1991  ; -------------------- Ordered Table Search Subroutine ---------------------
                     1992  ;
                     1993  ;  X is pointing to the start of the first value in the table
                     1994  ;  tmp1:2 initially hold the start of table address,
                     1995  ;  then they hold the bound values
                     1996  ;  tmp3 is the end of the table ("n" elements - 1)
                     1997  ;  tmp4 is the comparison value
                     1998  ;  tmp5 is the index result - if zero then comp value is less
                     1999  ;  than beginning of table, and if equal to "n" elements then it is
                     2000  ;  rail-ed at upper end
                     2001  ;
                     2002  ;***************************************************************************
                     2003  
                     2004  ORD_TABLE_FIND:
 8686 [03] 3F7B      2005       clr     tmp5     ; Clear tmp5 variable
 8688 [04] 5577      2006       ldhx    tmp1     ; Load high part of index register with value in tmp1
 868A [02] F6        2007       lda     ,x            ; Load accumulator with low part of index register???
 868B [03] B777      2008       sta     tmp1     ; Copy to tmp1 variable
 868D [03] B778      2009       sta     tmp2     ; Copy to tmp2 variable
                     2010  
                     2011  REENT:
 868F [01] 5C        2012       incx                    ; Increment low part of index register
 8690 [04] 3C7B      2013       inc     tmp5            ; Increment tmp5 variable
 8692 [05] 4E7877    2014       mov     tmp2,tmp1       ; Move value in tmp2 variable to tmp1 variable
 8695 [02] F6        2015       lda     ,x              ; Load accumulator with value in index reg Lo??
 8696 [03] B778      2016       sta     tmp2            ; Copy to tmp2 variable
 8698 [03] B17A      2017       cmp     tmp4            ; Compare it with tmp4 variable
 869A [03] 2206      2018       bhi     GOT_ORD_NUM     ; If higher, branch to GOT_ORD_NUM lable
 869C [03] B67B      2019       lda     tmp5            ; Load accumulator with value in tmp5 variable
 869E [03] B179      2020       cmp     tmp3            ; Compare it with value in tmp3 variable
 86A0 [03] 26ED      2021       bne     REENT           ; If the Z bit of CCR is clesr, branch to REENT:
                     2022  
                     2023  GOT_ORD_NUM:
 86A2 [04] 81        2024       rts                     ; Return from subroutine
                     2025  
                     2026  
                     2027  ;****************************************************************************
                     2028  ;
                     2029  ; ------------------ Linear Interpolation - 2D Subroutine -------------------
                     2030  ;
                     2031  ; Graph Plot        X2
                     2032  ;                   Y2
                     2033  ;               X
                     2034  ;               Y
                     2035  ;         X1
                     2036  ;         Y1
                     2037  ;            (Y2 - Y1)
                     2038  ;  Y = Y1 +  --------- * (X - X1)
                     2039  ;            (X2 - X1)


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 19
MC68HC908GP32 User Bootloader


                     2040  ;
                     2041  ;   tmp1 = X1
                     2042  ;   tmp2 = X2
                     2043  ;   tmp3 = Y1
                     2044  ;   tmp4 = Y2
                     2045  ;   tmp5 = X
                     2046  ;   tmp6 = Y
                     2047  ;***************************************************************************
                     2048  
                     2049  LININTERP:
 86A3 [03] 3F7D      2050       clr     tmp7          ; Clear tmp7 variable (This is the negative slope
                     2051                             ; detection bit) (tmp7 = 0)
 86A5 [05] 4E797C    2052       mov     tmp3,tmp6     ; Move value in tmp3 variable to tmp6 variable
                     2053                             ; (Y1 to tmp6)
                     2054  
                     2055  CHECK_LESS_THAN:
 86A8 [03] B67B      2056       lda     tmp5               ; Load accumulator with value in tmp5 variable
                     2057                                  ; (x)
 86AA [03] B177      2058       cmp     tmp1               ; Compare it with value in tmp1 variable
                     2059                                  ; (x1)
 86AC [03] 2202      2060       bhi     CHECK_GREATER_THAN ; If higher, branch to CHECK_GREATER_THAN:
                     2061                                  ; (X>X1)
 86AE [03] 2044      2062       bra     DONE_WITH_INTERP        ; Branch to DONE_WITH_INTERP: (else (Y=Y1))
                     2063  
                     2064  CHECK_GREATER_THAN:
 86B0 [03] B67B      2065       lda     tmp5             ; Load accumulator with value in tmp5 variable
                     2066                                ; (x)
 86B2 [03] B178      2067       cmp     tmp2             ; Compare it with value in tmp2 variable
                     2068                                ; (X2)
 86B4 [03] 2505      2069       blo     DO_INTERP        ; If lower, branch to DO_INTERP lable
                     2070                                ; (X<X2)
 86B6 [05] 4E7A7C    2071       mov     tmp4,tmp6        ; Move value in tmp4 variable to tmp6 variable
                     2072                                ; (Y2 to tmp6)
 86B9 [03] 2039      2073       bra     DONE_WITH_INTERP ; Branch to DONE_WITH_INTERP lable (else (Y=Y2))
                     2074  
                     2075  DO_INTERP:
 86BB [05] 4E797C    2076       mov     tmp3,tmp6        ; Move value in tmp3 variable to tmp6 variable
                     2077                                ; (Y1 to tmp6)
 86BE [03] B678      2078       lda     tmp2             ; Load accumulator with value in tmp2 variable
                     2079                                ; (X2)
 86C0 [03] B077      2080       sub     tmp1             ; Subtract tmp1 from tmp2 (A=X2-X1)
 86C2 [03] 2730      2081       beq     DONE_WITH_INTERP ; If the Z bit of CCR is set, branch to
                     2082                                ;DONE_WITH_INTERP:  else (Y=Y1)
 86C4 [02] 87        2083       psha                     ; Push value in accumulator to stack
                     2084                                ; (X2-X1)(stack 1)
 86C5 [03] B67A      2085       lda     tmp4             ; Load accumulator with value in tmp4 variable
                     2086                                ; (Y2)
 86C7 [03] B079      2087       sub     tmp3             ; Subtract tmp3 from tmp4 (A=Y2-Y1)
 86C9 [03] 2403      2088       bcc     POSINTERP        ; If C bit of CCR is clear, branch to POSINTERP:
 86CB [01] 40        2089       nega                     ; Negate accumulator      ??????????
 86CC [04] 3C7D      2090       inc     tmp7             ; Increment tmp7 variable (tmp7 = 1)
                     2091  
                     2092  POSINTERP:
 86CE [02] 87        2093       psha                     ; Push value in accumulator to stack
                     2094                                ; (negated Y2-Y1) (stack 2)
 86CF [03] B67B      2095       lda     tmp5             ; Load accumulator with value in tmp5 variable
                     2096                                ; (X)
 86D1 [03] B077      2097       sub     tmp1             ; Subtract tmp1 from tmp5 (A=X-X1)
 86D3 [03] 271D      2098       beq     ZERO_SLOPE            ; If the Z bit of CCR is set,
                     2099                                ; branch to ZERO_SLOPE lable  (Y=Y1)
 86D5 [02] 88        2100       pulx                     ; Pull value from stack to index register Lo
                     2101                                ;(negated Y2-Y1) (stack 2)
 86D6 [05] 42        2102       mul                      ; Multiply it by the value in the accumulator
                     2103                                ; A=(negated Y2-Y1)*(X-X1)
 86D7 [02] 89        2104       pshx                     ; Push the index register L to the stack
                     2105                                ; (stack 2)
 86D8 [02] 8A        2106       pulh                     ; Pull this value to index register Hi(stack 2)
 86D9 [02] 88        2107       pulx                     ; Pull the next value to index register Lo
                     2108                                ;(stack 1)
 86DA [07] 52        2109       div                      ; Divide A<-(H:A)/(X);H<-Remainder
 86DB [02] 87        2110       psha                     ; Push the value in the accumulator onto stack
                     2111                                ; (stack 1)
 86DC [03] B67D      2112       lda     tmp7             ; Load accumulator with value in tmp7 variable
 86DE [03] 2607      2113       bne     NEG_SLOPE        ; If the Z bit of CCR is clear,
                     2114                                ; branch to NEG_SLOPE: (Y=Y1)
 86E0 [02] 86        2115       pula                     ; Pull value from stack to accumulator (stack 1)
 86E1 [03] BB79      2116       add     tmp3             ; Add it with value in tmp3 variable
 86E3 [03] B77C      2117       sta     tmp6             ; Copy it to tmp6 variable
 86E5 [03] 200D      2118       bra     DONE_WITH_INTERP ; Branch to  DONE_WITH_INTERP:
                     2119  
                     2120  NEG_SLOPE:
 86E7 [02] 86        2121       pula                     ; Pull value from stack to accumulator(stack 1)
 86E8 [03] B77D      2122       sta     tmp7             ; Copy to tmp7 variable
 86EA [03] B679      2123       lda     tmp3             ; Load accumulator with value in tmp3  Y1)
 86EC [03] B07D      2124       sub     tmp7             ; Subtract tmp7 from tmp3
 86EE [03] B77C      2125       sta     tmp6             ; Copy result to tmp6 variable
 86F0 [03] 2002      2126       bra     DONE_WITH_INTERP ; Branch to  DONE_WITH_INTERP:
                     2127  
                     2128  ZERO_SLOPE:
 86F2 [02] 86        2129          pula    ; Pull value from stack to accumulator (clean stack)(stack 2)
 86F3 [02] 86        2130          pula    ; Pull value from stack to accumulator (clean stack)(stack 1)
                     2131  
                     2132  DONE_WITH_INTERP:
 86F4 [04] 81        2133          rts      ; Return from subroutine
                     2134  
                     2135  ;****************************************************************************
                     2136  ;
                     2137  ; ----------------- 32 x 16 Unsigned Divide Subroutine ---------------------
                     2138  ;
                     2139  ; This routine takes the 32-bit dividend stored in INTACC1.....INTACC1+3
                     2140  ; and divides it by the 16-bit divisor stored in INTACC2:INTACC2+1.
                     2141  ; The quotient replaces the dividend and the remainder replaces the divisor.
                     2142  ;
                     2143  ;***************************************************************************
                     2144  
 86F5                2145  UDVD32    EQU     *
                     2146  *
 86F5                2147  DIVIDEND  EQU     INTACC1+2
 86F5                2148  DIVISOR   EQU     INTACC2
 86F5                2149  QUOTIENT  EQU     INTACC1
 86F5                2150  REMAINDER EQU     INTACC1
                     2151  *
 86F5 [02] 8B        2152          PSHH                            ;save h-reg value
 86F6 [02] 87        2153          PSHA                            ;save accumulator
 86F7 [02] 89        2154          PSHX                            ;save x-reg value
 86F8 [02] A7FD      2155          AIS     #-3                     ;reserve three bytes of temp storage
 86FA [02] A620      2156          LDA     #!32                    ;
 86FC [04] 9EE703    2157          STA     3,SP                    ;loop counter for number of shifts
 86FF [03] B673      2158          LDA     DIVISOR                 ;get divisor msb
 8701 [04] 9EE701    2159          STA     1,SP                    ;put divisor msb in working storage
 8704 [03] B674      2160          LDA     DIVISOR+1               ;get divisor lsb
 8706 [04] 9EE702    2161          STA     2,SP                    ;put divisor lsb in working storage
                     2162  
                     2163  ****************************************************************************
                     2164  *     Shift all four bytes of dividend 16 bits to the right and clear
                     2165  *     both bytes of the temporary remainder location
                     2166  ****************************************************************************
                     2167  
 8709 [05] 4E7274    2168          MOV     DIVIDEND+1,DIVIDEND+3   ;shift dividend lsb
 870C [05] 4E7173    2169          MOV     DIVIDEND,DIVIDEND+2     ;shift 2nd byte of dividend
 870F [05] 4E7072    2170          MOV     DIVIDEND-1,DIVIDEND+1   ;shift 3rd byte of dividend
 8712 [05] 4E6F71    2171          MOV     DIVIDEND-2,DIVIDEND     ;shift dividend msb
 8715 [03] 3F6F      2172          CLR     REMAINDER               ;zero remainder msb
 8717 [03] 3F70      2173          CLR     REMAINDER+1             ;zero remainder lsb
                     2174  
                     2175  ****************************************************************************


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 20
MC68HC908GP32 User Bootloader


                     2176  *     Shift each byte of dividend and remainder one bit to the left
                     2177  ****************************************************************************
                     2178  
 8719 [03] B66F      2179  SHFTLP  LDA     REMAINDER               ;get remainder msb
 871B [01] 49        2180          ROLA                            ;shift remainder msb into carry
 871C [04] 3974      2181          ROL     DIVIDEND+3              ;shift dividend lsb
 871E [04] 3973      2182          ROL     DIVIDEND+2              ;shift 2nd byte of dividend
 8720 [04] 3972      2183          ROL     DIVIDEND+1              ;shift 3rd byte of dividend
 8722 [04] 3971      2184          ROL     DIVIDEND                ;shift dividend msb
 8724 [04] 3970      2185          ROL     REMAINDER+1             ;shift remainder lsb
 8726 [04] 396F      2186          ROL     REMAINDER               ;shift remainder msb
                     2187  
                     2188  *****************************************************************************
                     2189  *     Subtract both bytes of the divisor from the remainder
                     2190  *****************************************************************************
                     2191  
 8728 [03] B670      2192          LDA     REMAINDER+1          ;get remainder lsb
 872A [04] 9EE002    2193          SUB     2,SP                 ;subtract divisor lsb from remainder lsb
 872D [03] B770      2194          STA     REMAINDER+1          ;store new remainder lsb
 872F [03] B66F      2195          LDA     REMAINDER            ;get remainder msb
 8731 [04] 9EE201    2196          SBC     1,SP                 ;subtract divisor msb from remainder msb
 8734 [03] B76F      2197          STA     REMAINDER            ;store new remainder msb
 8736 [03] B674      2198          LDA     DIVIDEND+3           ;get low byte of dividend/quotient
 8738 [02] A200      2199          SBC     #0                   ;dividend low bit holds subtract carry
 873A [03] B774      2200          STA     DIVIDEND+3           ;store low byte of dividend/quotient
                     2201  
                     2202  *****************************************************************************
                     2203  *     Check dividend/quotient lsb. If clear, set lsb of quotient to indicate
                     2204  *     successful subraction, else add both bytes of divisor back to remainder
                     2205  *****************************************************************************
                     2206  
 873C [05] 017416    2207          BRCLR   0,DIVIDEND+3,SETLSB     ;check for a carry from subtraction
                     2208                                          ;and add divisor to remainder if set
 873F [03] B670      2209          LDA     REMAINDER+1             ;get remainder lsb
 8741 [04] 9EEB02    2210          ADD     2,SP                    ;add divisor lsb to remainder lsb
 8744 [03] B770      2211          STA     REMAINDER+1             ;store remainder lsb
 8746 [03] B66F      2212          LDA     REMAINDER               ;get remainder msb
 8748 [04] 9EE901    2213          ADC     1,SP                    ;add divisor msb to remainder msb
 874B [03] B76F      2214          STA     REMAINDER               ;store remainder msb
 874D [03] B674      2215          LDA     DIVIDEND+3              ;get low byte of dividend
 874F [02] A900      2216          ADC     #0                      ;add carry to low bit of dividend
 8751 [03] B774      2217          STA     DIVIDEND+3              ;store low byte of dividend
 8753 [03] 2002      2218          BRA     DECRMT                  ;do next shift and subtract
                     2219  
 8755 [04] 1074      2220  SETLSB  BSET    0,DIVIDEND+3            ;set lsb of quotient to indicate
                     2221                                          ;successive subtraction
 8757 [06] 9E6B03BE  2222  DECRMT  DBNZ    3,SP,SHFTLP             ;decrement loop counter and do next
                     2223                                          ;shift
                     2224  
                     2225  *****************************************************************************
                     2226  *     Move 32-bit dividend into INTACC1.....INTACC1+3 and put 16-bit
                     2227  *     remainder in INTACC2:INTACC2+1
                     2228  *****************************************************************************
                     2229  
 875B [03] B66F      2230          LDA     REMAINDER               ;get remainder msb
 875D [04] 9EE701    2231          STA     1,SP                    ;temporarily store remainder msb
 8760 [03] B670      2232          LDA     REMAINDER+1             ;get remainder lsb
 8762 [04] 9EE702    2233          STA     2,SP                    ;temporarily store remainder lsb
 8765 [05] 4E716F    2234          MOV     DIVIDEND,QUOTIENT       ;
 8768 [05] 4E7270    2235          MOV     DIVIDEND+1,QUOTIENT+1   ;shift all four bytes of quotient
 876B [05] 4E7371    2236          MOV     DIVIDEND+2,QUOTIENT+2   ; 16 bits to the left
 876E [05] 4E7472    2237          MOV     DIVIDEND+3,QUOTIENT+3   ;
 8771 [04] 9EE601    2238          LDA     1,SP                    ;get final remainder msb
 8774 [03] B773      2239          STA     INTACC2                 ;store final remainder msb
 8776 [04] 9EE602    2240          LDA     2,SP                    ;get final remainder lsb
 8779 [03] B774      2241          STA     INTACC2+1               ;store final remainder lsb
                     2242  
                     2243  *****************************************************************************
                     2244  *     Deallocate local storage, restore register values, and return from
                     2245  *     subroutine
                     2246  *****************************************************************************
                     2247  
 877B [02] A703      2248          AIS     #3                      ;deallocate temporary storage
 877D [02] 88        2249          PULX                            ;restore x-reg value
 877E [02] 86        2250          PULA                            ;restore accumulator value
 877F [02] 8A        2251          PULH                            ;restore h-reg value
 8780 [04] 81        2252          RTS                             ;return
                     2253  
                     2254  *****************************************************************************
                     2255  
                     2256  
                     2257  ;****************************************************************************
                     2258  ; ----------  ----- ROUND after div (unsigned) Subroutine -------------------
                     2259  ;
                     2260  ;  1)  check for div overflow (carry set), rail result if detected
                     2261  ;  2)  if (remainder * 2) > divisor then     ; was remainder > (divisor / 2)
                     2262  ;  2a)    increment result, rail if over-flow
                     2263  ;
                     2264  ;****************************************************************************
                     2265  
                     2266  DIVROUND:
 8781 [03] 250E      2267       bcs     DIVROUND0     ; If C bit of CCR is set, branch to DIVROUND0:
                     2268                             ; (div overflow? yes, branch)
 8783 [03] BF8C      2269       stx     local_tmp     ; Copy value in index register Lo byte to
                     2270                             ; local_tmp variable (divisor)
 8785 [02] 8B        2271       pshh                  ; Push value in index register Hi byte onto
                     2272                             ; stack (retrieve remainder)
 8786 [02] 88        2273       pulx                  ; Pull value on stack to index register Lo byte
 8787 [01] 58        2274       lslx                  ; Logical shift left index register lo byte (* 2)
 8788 [03] 2504      2275       bcs     DIVROUND2     ; If C bit of CCR is set, branch to DIVROUND2:
                     2276                             ;(over-flow on left-shift, (remainder * 2) > $FF)
 878A [03] B38C      2277       cpx     local_tmp     ; Compare value in local_tmp variable with value
                     2278                             ; in index register Lo byte
                     2279                             ;(compare (remainder * 2) to divisor)
 878C [03] 2505      2280       blo     DIVROUND1     ; If lower, branch to DIVROUND1:
                     2281  
                     2282  
                     2283  DIVROUND2:
 878E [01] 4C        2284       inca                   ; Increment accumulator (round-up result)
 878F [03] 2602      2285       bne      DIVROUND1     ; If Z bit of CCR is clear, branch to DIVROUND1:
                     2286                              ; (result roll over? no, branch)
                     2287  
                     2288  
                     2289  DIVROUND0:
 8791 [02] A6FF      2290       lda     #$FF     ; Load accumulator with decimal 255 (rail result)
                     2291  
                     2292  
                     2293  DIVROUND1:
 8793 [04] 81        2294       rts              ; return from subroutine
                     2295  
                     2296  
                     2297  ;****************************************************************************
                     2298  ;
                     2299  ; ------------------- 16 x 16 Unsigned Multiply Subroutine -----------------
                     2300  ;
                     2301  ;     tmp8...tmp5 = tmp4:tmp3 * tmp2:tmp1
                     2302  ;
                     2303  ;               tmp3*tmp1
                     2304  ;   +      tmp4*tmp1
                     2305  ;   +      tmp3*tmp2
                     2306  ;   + tmp4*tmp2
                     2307  ;   = ===================
                     2308  ;     tmp8 tmp7 tmp6 tmp5
                     2309  ;
                     2310  ;****************************************************************************
                     2311  


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 21
MC68HC908GP32 User Bootloader


                     2312  UMUL32:
 8794 [03] B677      2313       lda     tmp1        ; Load accumulator with value in tmp1 variable
 8796 [03] BE79      2314       ldx     tmp3        ; Load index register Lo byte with value in tmp3
 8798 [05] 42        2315       mul                 ; Multiply X:A<-(X)*(A)
 8799 [03] B77B      2316       sta     tmp5        ; Ccopy result to tmp5
 879B [03] BF7C      2317       stx     tmp6        ; Copy value in index register Lo byte to tmp6
                     2318  ;
 879D [03] B678      2319       lda     tmp2        ; Load accumulator with value in tmp2
 879F [03] BE7A      2320       ldx     tmp4        ; Load index register Lo byte with value in tmp4
 87A1 [05] 42        2321       mul                 ; Multiply X:A<-(X)*(A)
 87A2 [03] B77D      2322       sta     tmp7        ; Copy result to tmp7
 87A4 [03] BF7E      2323       stx     tmp8        ; Copy value in index register Lo byte to tmp8
                     2324  ;
 87A6 [03] B677      2325       lda     tmp1        ; Load accumulator with value in tmp1
 87A8 [03] BE7A      2326       ldx     tmp4        ; Load index register Lo byte with value in tmp4
 87AA [05] 42        2327       mul                 ; Multiply X:A<-(X)*(A)
 87AB [03] BB7C      2328       add     tmp6        ; Add without carry, A<-(A)+(M)
 87AD [03] B77C      2329       sta     tmp6        ; Copy result to tmp6
 87AF [01] 9F        2330       txa                 ; Transfer value in index register Lo byte
                     2331                           ; to accumulator
 87B0 [03] B97D      2332       adc     tmp7        ; Add with carry, A<-(A)+(M)+(C)
 87B2 [03] B77D      2333       sta     tmp7        ; Copy result to tmp7
 87B4 [03] 2402      2334       bcc     UMUL32a     ; If C bit of CCR is clear, branch to UMUL32a:
 87B6 [04] 3C7E      2335       inc     tmp8        ; Increment value in tmp8
                     2336  
                     2337  
                     2338  UMUL32a:
 87B8 [03] B678      2339       lda     tmp2        ; Load accumulator with value in tmp2
 87BA [03] BE79      2340       ldx     tmp3        ; Load index register Lo byte with value in tmp3
 87BC [05] 42        2341       mul                 ; Multiply X:A<-(X)*(A)
 87BD [03] BB7C      2342       add     tmp6        ; Add without carry, A<-(A)+(M)
 87BF [03] B77C      2343       sta     tmp6        ; Copy result to tmp6
 87C1 [01] 9F        2344       txa                 ; Transfer value in index register Lo byte
                     2345                           ; to accumulator
 87C2 [03] B97D      2346       adc     tmp7        ; Add with carry, A<-(A)+(M)+(C)
 87C4 [03] B77D      2347       sta     tmp7        ; Copy result to tmp7
 87C6 [03] 2402      2348       bcc     UMUL32b     ; If C bit of CCR is clear, branch to UMUL32b:
 87C8 [04] 3C7E      2349       inc     tmp8        ; increment value in tmp8 variable
                     2350  
                     2351  
                     2352  UMUL32b:
 87CA [04] 81        2353        rts                ; return from subroutine
                     2354  
                     2355  ;****************************************************************************
                     2356  ; Multiply then divide.
                     2357  ;****************************************************************************
                     2358  
                     2359  uMulAndDiv:
                     2360  
                     2361  ;****************************************************************************
                     2362  ; 8 x 16 Multiply
                     2363  ;
                     2364  ; 8-bit value in Accumulator, 16-bit value in tmp11-12, result overwrites
                     2365  ; 16-bit input.  Assumes result cannot overflow.
                     2366  ;
                     2367  ;  tmp12:tmp11<-tmp12:tmp11*(A)
                     2368  ;
                     2369  ****************************************************************************
                     2370  
                     2371  uMul16:
 87CB [02] 87        2372        psha              ; Push value in accumulator to stack
                     2373                          ;(Save multiplier)
 87CC [03] BE81      2374        ldx     tmp11     ; Load index register Lo byte with value in "tmp11"
                     2375                          ;(LSB of multiplicand)
 87CE [05] 42        2376        mul               ; Multiply (X:A)<-(X)*(A)
 87CF [03] B781      2377        sta     tmp11     ; Copy value in accumulator to "tmp11"
                     2378                          ;(LSB of result stored)
 87D1 [02] 86        2379        pula              ; Pull value from stack to acumulator
                     2380                          ;(Pop off multiplier)
 87D2 [02] 89        2381        pshx              ; Push value in index register Lo byyte to stack
                     2382                          ;(Carry on stack)
 87D3 [03] BE82      2383        ldx     tmp12     ; Load index register Lo byte with value in "tmp12"
                     2384                          ;(MSB of multiplicand)
 87D5 [05] 42        2385        mul               ; Multiply (X:A)<-(X)*(A)
 87D6 [04] 9EEB01    2386        add     1,SP      ; Add (A)<-(A)+(SP)
                     2387                          ;(Add in carry from LSB)
 87D9 [03] B782      2388        sta     tmp12     ; Copy value in accumulator to "tmp12"
                     2389                          ;(MSB of result)
 87DB [02] 86        2390        pula              ; Pull value in stack to accumulator
                     2391                          ;(Clear the stack)
                     2392  
                     2393  ;****************************************************************************
                     2394  ; 16-bit divide by 100T
                     2395  ;
                     2396  ; 16-bit value in tmp11-12 is divided by 100T.  Result is left in tmp11-12.
                     2397  ;
                     2398  ;  tmp12:tmp11<-tmp12:tmp11/100
                     2399  ;
                     2400  ;****************************************************************************
                     2401  
                     2402  uDivBy100:
 87DC [01] 8C        2403        clrh              ; Clear index register Hi byte
 87DD [03] B682      2404        lda     tmp12     ; Load accumulator with value in "tmp12"
                     2405                          ;(MSB of dividend)
 87DF [02] AE64      2406        ldx     #$64      ; Load index register Lo byte with decimal 100
                     2407                          ;(Divisor)
 87E1 [07] 52        2408        div               ; Divide (A)<-(H:A)/(X)
 87E2 [03] B782      2409        sta     tmp12     ; Copy value in accumulator to "tmp12"
                     2410                          ;(MSB of quotient)
 87E4 [03] B681      2411        lda     tmp11     ; Load accumulator with value in "tmp11"
                     2412                          ;(LSB of dividend)
 87E6 [07] 52        2413        div               ; Divide (A)<-(H:A)/(X)
 87E7 [03] B781      2414        sta     tmp11     ; Copy value in accumulator to "tmp11
                     2415                          ;(LSB of quotient)
                     2416  
                     2417  ;****************************************************************************
                     2418  ; - See if we need to round up the quotient.
                     2419  ;****************************************************************************
 87E9 [02] 8B        2420        pshh                         ; Push value in index register Hi byte
                     2421                                     ; to stack
 87EA [02] 86        2422        pula                         ; Pull value from stack to accumulator
                     2423                                     ;(H)->(A)(Remainder in A)
 87EB [02] A132      2424        cmp     #$32                 ; Compare value in accumulator with
                     2425                                     ; decimal 50(Half of the divisor)
 87ED [03] 9306      2426        ble     uDivRoundingDone     ; If less than or equal, branch to
                     2427                                     ; uDivRoundingDone:
 87EF [04] 3C81      2428        inc     tmp11                ; Increment value in "tmp11"
 87F1 [03] 2402      2429        bcc     uDivRoundingDone     ; If carry bit is clear, branch to
                     2430                                     ; uDivRoundingDone:
 87F3 [04] 3C82      2431        inc     tmp12                ; Increment value in "tmp12"
                     2432  
                     2433  uDivRoundingDone:
 87F5 [04] 81        2434        rts                          ; Return from subroutine
                     2435  
                     2436  
                     2437  ;***************************************************************************
                     2438  ; - Flash Burn routine goes here
                     2439  ;***************************************************************************
                     2440  
 87F6                2441       include "burner.asm"         ; Include Flash Burner routine
                     2442  ;*****************************************************************************
                     2443  ; Meagasquirt Flash page erase and programming routines
                     2444  ; heavily based on the routines from boot_r12.asm
                     2445  ;
                     2446  ;*****************************************************************************
                     2447  


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 22
MC68HC908GP32 User Bootloader


                     2448  ;-------------------------------------------------------------------------------
                     2449  ; burnConst: is a PCC compatible FLASH Programming Routine - I think
                     2450  ;-------------------------------------------------------------------------------
                     2451  
                     2452  burnConst:
 87F6 [03] 45E100    2453          ldhx    #ms_rf_start_f
 87F9 [04] 3593      2454          sthx    burnDst
 87FB [05] CD882F    2455          jsr     ms_EraseFlash           ; Erase the first 128 byte block
 87FE [04] 5593      2456          ldhx    burnDst
 8800 [02] AF40      2457          aix     #64T
 8802 [02] AF40      2458          aix     #64T
 8804 [04] 3593      2459          sthx    burnDst
 8806 [05] CD882F    2460          jsr     ms_EraseFlash           ; and the second
                     2461  
 8809 [03] 45E100    2462          ldhx    #ms_rf_start_f
 880C [04] 3593      2463          sthx    burnDst
 880E [03] 4500A0    2464          ldhx    #ms_rf_start
 8811 [04] 3591      2465          sthx    burnSrc
                     2466  
 8813 [02] A600      2467          lda     #$00                    ; burn the lot 256 bytes in all
 8815 [03] B795      2468          sta     burncount
                     2469  
 8817 [01] 8C        2470          clrh
 8818 [01] 5F        2471          clrx
 8819 [03] CC883D    2472          jmp     ms_ProgramFlash
                     2473  
                     2474  burnByte:
                     2475  ; byte to be burnt on stack, together with destination address
                     2476  ; Stack
                     2477  ;       byte
                     2478  ;       dest low
                     2479  ;       dest high
                     2480  ;
 881C [02] 86        2481          pula
 881D [03] B78B      2482          sta     tmp21
 881F [03] 45008B    2483          ldhx    #tmp21
 8822 [04] 3591      2484          sthx    burnSrc
 8824 [02] 88        2485          pulx
 8825 [02] 8A        2486          pulh
 8826 [04] 3593      2487          sthx    burnDst
 8828 [02] A601      2488          lda     #$01                    ; burn 1 byte
 882A [03] B795      2489          sta     burncount
 882C [03] CC883D    2490          jmp     ms_ProgramFlash
                     2491  
                     2492  ;-------------------------------------------------------------------------------
                     2493  
                     2494  
                     2495  ;*  Single Flash Page Erase Subroutine  ======================================
                     2496  ;*
                     2497  ; This subroutine will copy the Flash Erase algorithm into RAM and execute
                     2498  ; it to erase the page starting at address pointers "burnDst"
                     2499  ;
                     2500  ms_EraseFlash:
 882F [03] 450031    2501          ldhx    #ms_EraseRamSize                ; initialize pointer
                     2502  ms_EraseFlash1:
 8832 [04] D6884A    2503          lda     ms_MassErase-1,x                ; get program from Flash
 8835 [04] D701EC    2504          sta     ram_exec-1,x                    ; copy into RAM
 8838 [03] 5BF8      2505          dbnzx   ms_EraseFlash1                  ; decrement pointer and loop back until done
 883A [03] CC01ED    2506          jmp     ram_exec                        ; execute Flash Mass Erase algorithm from RAM
                     2507  
                     2508  ;*  Flash Program Subroutine  ================================================
                     2509  ;*
                     2510  ; This subroutine will copy the Flash Program algorithm into RAM and execute it
                     2511  ; to program 'burncount' bytes from the address pointed to by 'burnSrc' to the
                     2512  ; address pointed to by "burnDst"
                     2513  ;
                     2514  ms_ProgramFlash:
 883D [03] 45004A    2515          ldhx    #ms_ProgramRamSize              ; initialize pointer
                     2516  ms_ProgramFlash1:
 8840 [04] D68870    2517          lda     ms_Delay-1,x                    ; get program from Flash
 8843 [04] D701EC    2518          sta     ram_exec-1,x                    ; copy into RAM
 8846 [03] 5BF8      2519          dbnzx   ms_ProgramFlash1                ; decrement pointer and loop back until done
 8848 [03] CC01F8    2520          jmp     {ram_exec+ms_ProgramRam}
                     2521  ;
                     2522  ;
                     2523  ;*  Flash Erase Subroutine  ==================================================
                     2524  ;*
                     2525  ;*  This subroutine performs a single Page Erase @ BurnDst
                     2526  ;*  This subroutine has been
                     2527  ;*  tuned for a bus speed of 7.3728 MHz.
                     2528  ;*  This subroutine is copied into and executed from RAM.
                     2529  ;*
                     2530  ms_MassErase:
 884B [04] 5593      2531          ldhx    burnDst            ; initialize pointer to Flash memory address
                     2532  
                     2533  ;   Set ERASE, read the Flash Block Protect Register and write any data into Flash page.
                     2534  ;
 884D [02] A602      2535          lda     #{ERASE}                    ; set ERASE control bit
 884F [04] C7FE08    2536          sta     flcr                        ;  in Flash Control Register
 8852 [04] C6FF7E    2537          lda     flbpr                       ; read from Flash Block Protect Register
 8855 [02] F7        2538          sta     ,x                          ; write any data to address within page
                     2539  ;
                     2540  ;   Wait for >10us, then set HVEN.
                     2541  ;
 8856 [02] A601      2542          lda     #1                          ; wait
 8858 [04] AD17      2543          bsr     ms_delay                       ;  for 11.7us
 885A [02] A60A      2544          lda     #{ERASE | HVEN}             ; set HVEN control bit
 885C [04] C7FE08    2545          sta     flcr                        ;  in Flash Control Register
                     2546  ;
                     2547  ;   Wait for >1ms, then clear ERASE.
                     2548  ;
 885F [02] A664      2549          lda     #100T                        ; wait
 8861 [04] AD0E      2550          bsr     ms_delay                       ;  for 1.005ms
 8863 [02] A608      2551          lda     #{HVEN}                     ; clear ERASE control bit
 8865 [04] C7FE08    2552          sta     flcr                        ;  in Flash Control Register
                     2553  ;
                     2554  ;   Wait for >5us, then clear HVEN.
                     2555  ;
 8868 [02] A601      2556          lda     #1                          ; wait
 886A [04] AD05      2557          bsr     ms_delay                       ;  for 11.7us
 886C [01] 4F        2558          clra                                ; clear HVEN control bit
 886D [04] C7FE08    2559          sta     flcr                        ;  in Flash Control Register
                     2560  
 8870 [04] 81        2561          rts                                 ; return
                     2562  
                     2563  
                     2564  ;*  Delay Subroutine  =======================================================================
                     2565  ;*
                     2566  ;*  This subroutine performs a simple software delay loop based upon the value passed in ACC.
                     2567  ;*  The following timing calculation applies:
                     2568  ;*
                     2569  ;*              delay = ((ACC * 74) + 12) (tcyc)
                     2570  ;*
                     2571  ;*  Calling convention:
                     2572  ;*
                     2573  ;*      lda     data
                     2574  ;*      jsr     delay
                     2575  ;*
                     2576  ;*  Returns:    nothing
                     2577  ;*
                     2578  ;*  Changes:    ACC
                     2579  ;*
                     2580  ms_Delay:
 8871 [02] 87        2581          psha                                ; [2] save outer delay loop parameter
                     2582  ms_Delay1:
 8872 [02] A622      2583          lda     #22                         ; [2] initialize inner delay loop counter


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 23
MC68HC908GP32 User Bootloader


                     2584  ms_Delay2:
 8874 [03] 4BFE      2585          dbnza   ms_Delay2                      ; [3] decrement inner delay loop counter
 8876 [06] 9E6B01F8  2586          dbnz    1,sp,ms_Delay1                 ; [6] decrement outer delay loop counter
 887A [02] 86        2587          pula                                ; [2] deallocate local variable
 887B [04] 81        2588          rts                                 ; [4] return
                     2589  
 887C                2590  ms_EraseRamSize:   equ     {*-ms_MassErase}
 887C                2591  ms_ProgramRam:     equ     {*-ms_Delay}
                     2592  
                     2593  ;*  Flash Program Subroutine  ===============================================================
                     2594  ;*
                     2595  ;*  This subroutine controls the Flash programming sequence.
                     2596  
                     2597  ms_FlashProgram:
                     2598  
                     2599  ms_FlashProgram1:
                     2600  
                     2601  ;   Set PGM, read the Flash Block Protect Register and write anywhere in desired Flash row.
                     2602  ;
 887C [02] A601      2603          lda     #{PGM}                      ; set PGM control bit
 887E [04] C7FE08    2604          sta     flcr                        ;  in Flash Control Register
 8881 [04] C6FF7E    2605          lda     flbpr                       ; read from Flash Block Protect Register
 8884 [04] 5593      2606          ldhx    burnDst
 8886 [02] F7        2607          sta     ,x                   ; write any data to first Flash address
                     2608  ;
                     2609  ;   Wait for >10us, then set HVEN.
 8887 [02] A601      2610          lda     #1                          ; wait
 8889 [04] ADE6      2611          bsr     ms_delay                       ;  for 11.7us
 888B [02] A609      2612          lda     #{PGM | HVEN}               ; set HVEN control bit
 888D [04] C7FE08    2613          sta     flcr                        ;  in Flash Control Register
                     2614  ;
                     2615  ;   Wait for >5us.
 8890 [02] A601      2616          lda     #1                          ; wait
 8892 [04] ADDD      2617          bsr     ms_delay                       ;  for 11.7us
                     2618  ;
                     2619  ;   Write data to Flash and wait for 30 - 40us.
 8894 [04] 5591      2620          ldhx    burnsrc
 8896 [02] F6        2621          lda     ,x                   ; get data byte
 8897 [04] 5593      2622          ldhx    burndst
 8899 [02] F7        2623          sta     ,x                   ; write data to Flash
 889A [02] A603      2624          lda     #3                          ; wait
 889C [04] ADD3      2625          bsr     ms_delay                       ;  for 31.7us
                     2626  ;
                     2627  ;   Clear PGM.
 889E [02] A608      2628          lda     #{HVEN}                     ; clear PGM
 88A0 [04] C7FE08    2629          sta     flcr                        ;  in Flash Control Register
                     2630  ;
                     2631  ;   Wait for >5us, then clear HVEN.
 88A3 [02] A601      2632          lda     #1                          ; wait
 88A5 [04] ADCA      2633          bsr     ms_delay                       ;  for 11.7us
 88A7 [01] 4F        2634          clra                                ; clear HVEN control bit
 88A8 [04] C7FE08    2635          sta     flcr                        ;  in Flash Control Register
                     2636  ;
                     2637  ;   Advance destination pointer and decrement data counter.
                     2638  ;
                     2639  ms_FlashProgram2:
 88AB [04] 5591      2640          ldhx    burnsrc
 88AD [02] AF01      2641          aix     #1                          ; advance source pointer
 88AF [04] 3591      2642          sthx    BurnSrc
 88B1 [04] 5593      2643          ldhx    burndst
 88B3 [02] AF01      2644          aix     #1                          ; advance destination pointer
 88B5 [04] 3593      2645          sthx    BurnDst
 88B7 [05] 3B95C2    2646          dbnz    burncount,ms_FlashProgram1  ; decrement counter and loop
                     2647                                              ; back if not done.
 88BA [04] 81        2648          rts                                 ; return
                     2649  
 88BB                2650  ms_ProgramRamSize: equ     {*-ms_Delay}
                     2651  
                     2652  
                     2653  
                     2654  ;****************************************************************************
                     2655  ;-------------------Constants not possible to burn--------------------------
                     2656  ;****************************************************************************
                     2657  
 E000                2658          org     $E000      ; (57344)
                     2659  
                     2660  
                     2661  REVNUM:
 E000      0A        2662          db      10T     ; Revision 1.0
                     2663  
 E001      202A2A20  2664  Signature db 32T,'** V5.00 Embedded Code by RJH **'
           56352E30 
           3020456D 
           62656464 
           65642043 
           6F646520 
           62792052 
           4A48202A 
           2A 
                     2665  
                     2666  
                     2667  ;****************************************************************************
                     2668  ; - Flash Configuration Constants (copied into RAM at start up)
                     2669  ;****************************************************************************
                     2670  
 E100                2671          org     $E100      ; SE100 to $E1C0 (57600 to 57792)
                     2672  
                     2673  ms_rf_start_f:
                     2674  
                     2675  ;****************************************************************************
                     2676  ; - Servo travel pulse width limits
                     2677  ;   These are used to calibrate the individual servo travel pulse widths.
                     2678  ;   Initial settings are for full travel which is 1100uS min ($04:4C), and
                     2679  ;   1900uS Max ($07:6C). The burner routine burns 64 bytes at a time
                     2680  ;****************************************************************************
                     2681  
 E100      04        2682       db     $04     ;SSpwMnH_F (Servo S OC value at open choke Hi byte)
 E101      4C        2683       db     $4C     ;SSpwMnL_F (Servo S OC value at open choke Lo byte)
 E102      07        2684       db     $07     ;SSpwMxH_F (Servo S OC value at closed choke Hi byte)
 E103      6C        2685       db     $6C     ;SSpwMxL_F (Servo S OC value at closed choke Lo byte)
 E104      04        2686       db     $04     ;SPpwMnH_F (Servo P OC value at open choke Hi byte)
 E105      4C        2687       db     $4C     ;SPpwMnL_F (Servo P OC value at open choke Lo byte)
 E106      07        2688       db     $07     ;SPpwMxH_F (Servo P OC value at closed choke Hi byte)
 E107      6C        2689       db     $6C     ;SPpwMxL_F (Servo P OC value at closed choke Lo byte)
                     2690  
                     2691  
                     2692  ;****************************************************************************
                     2693  ; - Place holders for future use
                     2694  ;****************************************************************************
                     2695  
 E108      00        2696      db     $00      ; blank_0
 E109      00        2697      db     $00      ; blank_1
 E10A      00        2698      db     $00      ; blank_2
 E10B      00        2699      db     $00      ; blank_3
 E10C      00        2700      db     $00      ; blank_4
 E10D      00        2701      db     $00      ; blank_5
 E10E      00        2702      db     $00      ; blank_6
 E10F      00        2703      db     $00      ; blank_7
 E110      00        2704      db     $00      ; blank_8
 E111      00        2705      db     $00      ; blank_9
 E112      00        2706      db     $00      ; blank_10
 E113      00        2707      db     $00      ; blank_11
 E114      00        2708      db     $00      ; blank_12
 E115      00        2709      db     $00      ; blank_13
 E116      00        2710      db     $00      ; blank_14
 E117      00        2711      db     $00      ; blank_15


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 24
MC68HC908GP32 User Bootloader


 E118      00        2712      db     $00      ; blank_16
 E119      00        2713      db     $00      ; blank_17
 E11A      00        2714      db     $00      ; blank_18
 E11B      00        2715      db     $00      ; blank_19
 E11C      00        2716      db     $00      ; blank_20
 E11D      00        2717      db     $00      ; blank_21
 E11E      00        2718      db     $00      ; blank_22
 E11F      00        2719      db     $00      ; blank_23
 E120      00        2720      db     $00      ; blank_24
 E121      00        2721      db     $00      ; blank_25
 E122      00        2722      db     $00      ; blank_26
 E123      00        2723      db     $00      ; blank_27
 E124      00        2724      db     $00      ; blank_28
 E125      00        2725      db     $00      ; blank_29
 E126      00        2726      db     $00      ; blank_30
 E127      00        2727      db     $00      ; blank_31
 E128      00        2728      db     $00      ; blank_32
 E129      00        2729      db     $00      ; blank_33
 E12A      00        2730      db     $00      ; blank_34
 E12B      00        2731      db     $00      ; blank_35
 E12C      00        2732      db     $00      ; blank_36
 E12D      00        2733      db     $00      ; blank_37
 E12E      00        2734      db     $00      ; blank_38
 E12F      00        2735      db     $00      ; blank_39
 E130      00        2736      db     $00      ; blank_40
 E131      00        2737      db     $00      ; blank_41
 E132      00        2738      db     $00      ; blank_42
 E133      00        2739      db     $00      ; blank_43
 E134      00        2740      db     $00      ; blank_44
 E135      00        2741      db     $00      ; blank_45
 E136      00        2742      db     $00      ; blank_46
 E137      00        2743      db     $00      ; blank_47
 E138      00        2744      db     $00      ; blank_48
 E139      00        2745      db     $00      ; blank_49
 E13A      00        2746      db     $00      ; blank_50
 E13B      00        2747      db     $00      ; blank_51
 E13C      00        2748      db     $00      ; blank_52
 E13D      00        2749      db     $00      ; blank_53
 E13E      00        2750      db     $00      ; blank_54
 E13F      00        2751      db     $00      ; blank_55
                     2752  
                     2753  
                     2754  ms_rf_end_f:
                     2755  
                     2756  ;***************************************************************************
                     2757  ; - Boot Loader routine goes here
                     2758  ;***************************************************************************
                     2759  
 E140                2760       include "boot_r12.asm"       ; Include Boot Loader routine
                     2761  ;=====================================
                     2762  ; MEGASQUIRT BOOTLOADER VERSION - Dec 2001
                     2763  ;
                     2764  ; Mods by Bruce Bowling
                     2765  ;
                     2766  ; Corrected bug in BootReset 5
                     2767  ;
                     2768  ;=====================================
                     2769  
                     2770  ;********************************************************************************************
                     2771  ;*                                                                                          *
                     2772  ;*  Bootloader - MC68HC908GP32                                                              *
                     2773  ;*                                                          Copyright (c) Motorola, 2001    *
                     2774  ;*                                                                                          *
                     2775  ;********************************************************************************************
                     2776  ;*                                                                                          *
                     2777  ;*  This file provides the low level assembly bootloader routine.                           *
                     2778  ;*  This program has been specially tailored towards the MC68HC908GP32.                     *
                     2779  ;*                                                                                          *
                     2780  ;********************************************************************************************
                     2781  ;*                                                                                          *
                     2782  ;*  File name:          boot.asm                        Current Release Level:      1.1     *
                     2783  ;*  Last Edit Date:     07-Jun-01                       Classification:             ES      *
                     2784  ;*                                                                                          *
                     2785  ;*  Include Files:      gp32.equ            : MC68HC908GP32 MCU definitions                 *
                     2786  ;*                                                                                          *
                     2787  ;*  Assembler:          P&E's CASM08Z                   Version:    3.16                    *
                     2788  ;*                                                                                          *
                     2789  ;*  Target:             MC68HC908GP32                                                       *
                     2790  ;*                                                                                          *
                     2791  ;*  Documentation:      MC68HC908GP32/H  Rev 3                                              *
                     2792  ;*                      Motorola Microcontroller Technical Data                             *
                     2793  ;*                                                                                          *


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 25
MC68HC908GP32 User Bootloader


                     2794  ;********************************************************************************************
                     2795  ;*                                                                                          *
                     2796  ;*  Author:             DHJ Klotz                                                           *
                     2797  ;*  First Release:      26-Feb-00                                                           *
                     2798  ;*                                                                                          *
                     2799  ;*  Update History:                                                                         *
                     2800  ;*                                                                                          *
                     2801  ;*  Rev     Date       Author  Description of Change                                        *
                     2802  ;*  ------  ---------  ------  -----------------------------------------------------------  *
                     2803  ;*  ES 1.0  26-Feb-00  DHJK    Initial release for HC908 Seminar 2000.                      *
                     2804  ;*  ES 1.1  07-Jun-01  DHJK    Improved functionality for Application Note.                 *
                     2805  ;*                                                                                          *
                     2806  ;********************************************************************************************
                     2807  ;*                                                                                          *
                     2808  ;*  Notes:                                                                                  *
                     2809  ;*    - In order to minimize overall program size, subroutines are position within the      *
                     2810  ;*      core bootloader routine.  Although this can make the program somewhat difficult     *
                     2811  ;*      to read and follow, it permits the use of relative branch opcodes.  Most of         *
                     2812  ;*      these subroutines can be called from an external application program.               *
                     2813  ;*                                                                                          *
                     2814  ;********************************************************************************************
                     2815  ;*                                                                                          *
                     2816  ;*    Motorola reserves the right to make changes without further notice to any product     *
                     2817  ;*    herein to improve reliability, function, or design.  Motorola does not assume any     *
                     2818  ;*    liability arising out of the application or use of any product, circuit, or software  *
                     2819  ;*    described herein; neither does it convey any license under its patent rights nor the  *
                     2820  ;*    rights of others.  Motorola products are not designed, intended, or authorized for    *
                     2821  ;*    use as components in systems intended for surgical implant into the body, or other    *
                     2822  ;*    applications intended to support life, or for any other application in which the      *
                     2823  ;*    failure of the Motorola product could create a situation where personal injury or     *
                     2824  ;*    death may occur.  Should Buyer purchase or use Motorola products for any such         *
                     2825  ;*    intended or unauthorized application, Buyer shall indemnify and hold Motorola and     *
                     2826  ;*    its officers, employees, subsidiaries, affiliates, and distributors harmless against  *
                     2827  ;*    all claims, costs, damages, and expenses, and reasonable attorney fees arising out    *
                     2828  ;*    of, directly or indirectly, any claim of personal injury or death associated with     *
                     2829  ;*    such unintended or unauthorized use, even if such claim alleges that Motorola was     *
                     2830  ;*    negligent regarding the design or manufacture of the part.                            *
                     2831  ;*                                                                                          *
                     2832  ;*    Motorola and the Motorola logo are registered trademarks of Motorola Ltd.             *
                     2833  ;*                                                                                          *
                     2834  ;********************************************************************************************
                     2835  
                     2836  ;*  Microcontroller Peripheral Equates  *****************************************************
                     2837  ;*
                     2838  
                     2839  ; uncomment out if standalone
 E140                2840          list
                     2841  
                     2842  
                     2843  ;*  Flash Memory Specifics  =================================================================
                     2844  ;*
 E140                2845  boot_start:     equ     $FB00               ; starting address of protected Bootloader
 E140                2846  flash_protect:  equ     {boot_start>7&$FF}  ; Flash Block Protect Register value
 E140                2847  flash_page:     equ     128                 ; Flash Erase Page size
 E140                2848  flash_row:      equ     64                  ; Flash Program Row size
 E140                2849  flash_erased:   equ     $FF                 ; Flash erased state
                     2850  
                     2851  
                     2852  ;*  RAM Utilization  ========================================================================
                     2853  ;*
 0040                2854          org     ram_start                   ; begining of RAM
                     2855  
 0040                2856  count:          ds      1                   ; 0040:     => data counter
 0041                2857  temp_sp:        ds      2                   ; 0041:0042 => temporary Stack Pointer storage
 0043                2858  flash_first:    ds      2                   ; 0043:0044 => first Flash reprogram address
 0045                2859  flash_last:     ds      2                   ; 0045:0046 => last Flash reprogram address + 1
                     2860  
 0047                2861  ram_exec:       equ     $01ED               ; start of executable RAM space
                     2862  
                     2863  
                     2864  ;*  Bootloader Customization Parameters  ====================================================
                     2865  ;*
 0047                2866  user_scbr:      equ     boot_start-61       ; FAC3      => SCBR register
 0047                2867  init_scbr:      equ     $12                 ;   default set SCI for 9600 kbaud
                     2868  
 0047                2869  user_config1:   equ     boot_start-60       ; FAC4      => CONFIG1 register
 0047                2870  init_config1:   equ     %00000001           ;   default CONFIG1
                     2871  
 0047                2872  user_config2:   equ     boot_start-59       ; FAC5      => CONFIG2 register
 0047                2873  init_config2:   equ     %00000001           ;   default CONFIG2
                     2874  
 0047                2875  user_first:     equ     boot_start-58       ; FAC6:FAC7 => 1st application address


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 26
MC68HC908GP32 User Bootloader


 0047                2876  init_first:     equ     rom_start           ;   default first Flash address
                     2877  
 0047                2878  user_last:      equ     boot_start-56       ; FAC8:FAC9 => last application address
 0047                2879  init_last:      equ     boot_start          ;   default last Flash address
                     2880  
                     2881  
                     2882  ;*  Application Program Jump Vector Table  ==================================================
                     2883  ;*
                     2884                                              ; FACA      => "JMP ext" instruction (opcode $CC)
 0047                2885  user_timebase:  equ     boot_start-54       ; FACB:FACC => user Timebase jump vector
                     2886  
                     2887                                              ; FACD      => "JMP ext" instruction (opcode $CC)
 0047                2888  user_ADC:       equ     boot_start-51       ; FACE:FACF => user ADC jump vector
                     2889  
                     2890                                              ; FAD0      => "JMP ext" instruction (opcode $CC)
 0047                2891  user_keyboard:  equ     boot_start-48       ; FAD1:FAD2 => user Keyboard jump vector
                     2892  
                     2893                                              ; FAD3      => "JMP ext" instruction (opcode $CC)
 0047                2894  user_SCItx:     equ     boot_start-45       ; FAD4:FAD5 => user SCI transmit jump vector
                     2895  
                     2896                                              ; FAD6      => "JMP ext" instruction (opcode $CC)
 0047                2897  user_SCIrx:     equ     boot_start-42       ; FAD7:FAD8 => user SCI receive jump vector
                     2898  
                     2899                                              ; FAD9      => "JMP ext" instruction (opcode $CC)
 0047                2900  user_SCIerr:    equ     boot_start-39       ; FADA:FADB => user SCI error jump vector
                     2901  
                     2902                                              ; FADC      => "JMP ext" instruction (opcode $CC)
 0047                2903  user_SPItx:     equ     boot_start-36       ; FADD:FADE => user SPI transmit jump vector
                     2904  
                     2905                                              ; FADF      => "JMP ext" instruction (opcode $CC)
 0047                2906  user_SPIrx:     equ     boot_start-33       ; FAE0:FAE1 => user SPI receive jump vector
                     2907  
                     2908                                              ; FAE2      => "JMP ext" instruction (opcode $CC)
 0047                2909  user_Tim2Ov:    equ     boot_start-30       ; FAE3:FAE4 => user Timer 2 overflow jump vector
                     2910  
                     2911                                              ; FAE5      => "JMP ext" instruction (opcode $CC)
 0047                2912  user_Tim2Ch1:   equ     boot_start-27       ; FAE6:FAE7 => user Timer 2 channel 1 jump vector
                     2913  
                     2914                                              ; FAE8      => "JMP ext" instruction (opcode $CC)
 0047                2915  user_Tim2Ch0:   equ     boot_start-24       ; FAE9:FAEA => user Timer 2 channel 0 jump vector
                     2916  
                     2917                                              ; FAEB      => "JMP ext" instruction (opcode $CC)
 0047                2918  user_Tim1Ov:    equ     boot_start-21       ; FAEC:FAED => user Timer 1 oveflow jump vector
                     2919  
                     2920                                              ; FAEE      => "JMP ext" instruction (opcode $CC)
 0047                2921  user_Tim1Ch1:   equ     boot_start-18       ; FAEF:FAF0 => user Timer 1 channel 1 jump vector
                     2922  
                     2923                                              ; FAF1      => "JMP ext" instruction (opcode $CC)
 0047                2924  user_Tim1Ch0:   equ     boot_start-15       ; FAF2:FAF3 => user Timer 1 channel 0 jump vector
                     2925  
                     2926                                              ; FAF4      => "JMP ext" instruction (opcode $CC)
 0047                2927  user_PLL:       equ     boot_start-12       ; FAF5:FAF6 => user PLL jump vector
                     2928  
                     2929                                              ; FAF7      => "JMP ext" instruction (opcode $CC)
 0047                2930  user_IRQ:       equ     boot_start-9        ; FAF8:FAF9 => user IRQ jump vector
                     2931  
                     2932                                              ; FAFA      => "JMP ext" instruction (opcode $CC)
 0047                2933  user_SWI:       equ     boot_start-6        ; FAFB:FAFC => user SWI jump vector
                     2934  
                     2935                                              ; FAFD      => "JMP ext" instruction (opcode $CC)
 0047                2936  user_reset:     equ     boot_start-3        ; FAFE:FAFF => user Reset interrupt jump vector
                     2937  
                     2938  
                     2939  ;*  Bootloader Program  *********************************************************************
                     2940  ;*
                     2941  
 0047                2942  init_stack:     equ     ram_exec-1          ; initialize stack pointer to before RAM routine
                     2943  ;
 0047                2944  init_scc1:      equ     %01000000           ; enable SCI, 8-bits, no parity, 1 stop
 0047                2945  init_scc2:      equ     %00001100           ; no interupts, receiver and transmitter enabled
                     2946  
 FB00                2947          org     boot_start                  ; beginning of code
                     2948  
                     2949  
                     2950  ;*  CGM Parameter Tables  ===================================================================
                     2951  ;*
                     2952  ;*  The following CGM parameter tables are placed here so that they are easy to access via
                     2953  ;*  external application programs.
                     2954  ;*
                     2955  ;*  7.3728 MHz bus frequency parameters (located at address "boot_start").
                     2956  ;*
                     2957  bus7372800:


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 27
MC68HC908GP32 User Bootloader


 FB00      02        2958          db      $02                         ; P & E
 FB01      C0        2959          db      $C0                         ; L
 FB02      03        2960          db      $03                         ; N msb
 FB03      84        2961          db      $84                         ; N lsb
                     2962  
                     2963  ;*  8.003584 MHz bus frequency parameters (located at address "boot_start+4").
                     2964  ;*
                     2965  bus8003584:
 FB04      02        2966          db      $02                         ; P & E
 FB05      D0        2967          db      $D0                         ; L
 FB06      03        2968          db      $03                         ; N msb
 FB07      D1        2969          db      $D1                         ; N lsb
                     2970  
                     2971  
                     2972  ;*  Power-on Reset  =========================================================================
                     2973  ;* MODIFIED FOR MEGASQUIRT - Initialization code here
                     2974  ;*
                     2975  
                     2976  BootReset:
 FB08 [01] 4F        2977          clra
 FB09 [04] C7FFFF    2978          sta     copctl
 FB0C [04] 6E011E    2979          mov     #%00000001,config2
 FB0F [04] 6E011F    2980          mov     #%00000001,config1
 FB12 [03] 450240    2981          ldhx    #ram_last+1
 FB15 [02] 94        2982          txs
                     2983  
 FB16 [03] 45FB00    2984          ldhx    #bus7372800                 ; point to 7.3728 MHz parameters
 FB19 [04] AD22      2985          bsr     PLLset                      ; change bus speed
                     2986  
 FB1B [02] A600      2987          lda      #%00000000
 FB1D [03] B705      2988          sta      ddrb                       ; ADC Channels - inputs
                     2989  
 FB1F [02] A670      2990          lda     #%01110000                  ; Set up ADC for divide by 8 and internal clock
 FB21 [03] B73E      2991          sta     adclk
 FB23 [02] A604      2992          lda     #%00000100                  ; No interrupt, channel AD4 selected
 FB25 [03] B73C      2993          sta     adscr
 FB27 [05] 0F3CFD    2994          brclr   coco,adscr,*                ; wait until conversion complete
                     2995  
 FB2A [03] B63D      2996          lda     adr
 FB2C [02] A105      2997          cmp     #$05                        ; Check for low voltage on divider
 FB2E [03] 2529      2998          blo     BootReset1                  ; enter bootloader if low voltage
                     2999  
                     3000  ;
                     3001  ;   Test application reset vector.
                     3002  ;
 FB30 [04] C6FAFE    3003          lda     user_reset+1                ; get the MSB of the user reset vector
 FB33 [02] A1FF      3004          cmp     #flash_erased               ; check if it's erased
 FB35 [03] 2722      3005          beq     BootReset1                  ; enter bootloader if erased
 FB37 [03] 20C4      3006          bra     user_reset                  ; else, jump to user reset jump vector
                     3007  
                     3008  
                     3009  ;*  External CGM PLL Bus Frequency Change Subroutine  =======================================
                     3010  ;*
                     3011  ;*  This subroutine will program the CGM PLL to change the bus frequency in accordance with
                     3012  ;*  the data being pointed to by X:A (which is a common implementation for pointer parameter
                     3013  ;*  passing used by HC08 C compilers).
                     3014  ;*
                     3015  ;*  C function prototype:
                     3016  ;*
                     3017  ;*      void CGMChange (char parameters*);
                     3018  ;*
                     3019  ;*  Calling convention:
                     3020  ;*
                     3021  ;*      ldx     #{parameters>8}             ; get CGM parameter table address msb
                     3022  ;*      lda     #{parameters&$FF}           ; get CGM parameter table address lsb
                     3023  ;*      jsr     CGMChange                   ; go change the bus speed
                     3024  ;*
                     3025  ;*  Returns:    nothing
                     3026  ;*
                     3027  ;*  Changes:    H:X
                     3028  ;*
                     3029  CGMChange:
 FB39 [02] 87        3030          psha                                ; save pointer lsb on stack
 FB3A [02] 89        3031          pshx                                ; save pointer msb on stack
 FB3B [02] 8A        3032          pulh                                ; initialize
 FB3C [02] 88        3033          pulx                                ;  H:X points to data array
                     3034  
                     3035  
                     3036  ;*  Internal CGM PLL Bus Frequency Change Subroutine  =======================================
                     3037  ;*
                     3038  ;*  This subroutine will program the CGM PLL to change the bus frequency in accordance with
                     3039  ;*  the data being pointed to by H:X.


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 28
MC68HC908GP32 User Bootloader


                     3040  ;*
                     3041  ;*  Calling convention:
                     3042  ;*
                     3043  ;*      ldhx    #parameters                 ; point to CGM parameter table
                     3044  ;*      jsr     PLLset                      ; go change the bus speed
                     3045  ;*
                     3046  ;*  Returns:    nothing
                     3047  ;*
                     3048  ;*  Changes:    H:X
                     3049  ;*
                     3050  PLLset:
 FB3D [04] 1936      3051          bclr    BCS,pctl                    ; select external reference as base clock
 FB3F [04] 1B36      3052          bclr    PLLON,pctl                  ; turn off PLL
 FB41 [04] 7E36      3053          mov     x+,pctl                     ; program P & E
 FB43 [04] 7E3A      3054          mov     x+,pmrs                     ; program L
 FB45 [04] 7E38      3055          mov     x+,pmsh                     ; program N msb
 FB47 [04] 7E39      3056          mov     x+,pmsl                     ; program N lsb
 FB49 [04] 1E37      3057          bset    AUTO,pbwc                   ; enable automatic bandwidth control
 FB4B [04] 1A36      3058          bset    PLLON,pctl                  ; turn on PLL
                     3059  PLLwait:
 FB4D [05] 0D37FD    3060          brclr   LOCK,pbwc,PLLwait           ; wait for PLL to lock (Note: won't simulate)
 FB50 [04] 1836      3061          bset    BCS,pctl                    ; select VCO as base clock
 FB52 [04] 81        3062          rts                                 ; return
                     3063  
                     3064  
                     3065  ;*  PutChar Subroutine  =====================================================================
                     3066  ;*
                     3067  ;*  This subroutine will output the character passed in ACC to the SCI.
                     3068  ;*
                     3069  ;*  C function prototype:
                     3070  ;*
                     3071  ;*      void PutChar (char data);
                     3072  ;*
                     3073  ;*  Calling convention:
                     3074  ;*
                     3075  ;*      lda     data                        ; get character
                     3076  ;*      jsr     PutChar                     ; go output it
                     3077  ;*
                     3078  ;*  Returns:    nothing
                     3079  ;*
                     3080  ;*  Changes:    nothing
                     3081  ;*
                     3082  PutChar:
 FB53 [05] 0F16FD    3083          brclr   SCTE,scs1,PutChar           ; wait until SCI transmitter is empty
 FB56 [03] B718      3084          sta     scdr                        ; output character to the SCI
 FB58 [04] 81        3085          rts                                 ; return
                     3086  
                     3087  
                     3088  ;*  Power-on Reset Bootloader Entry  ========================================================
                     3089  ;*
                     3090  ;*  This is where the Bootloader starts from power-on reset.
                     3091  ;*
                     3092  BootReset1:
                     3093  ;
                     3094  ;   Initialize the PLL CGM for 7.3728 MHz bus speed from 32.768 kHz crystal.
                     3095  ;
                     3096  ;        ldhx    #bus7372800                 ; point to 7.3728 MHz parameters
                     3097  ;        bsr     PLLset                      ; change bus speed
                     3098  ;
                     3099  ;   Copy user Flash parameters into RAM.
                     3100  ;
 FB59 [03] 45FAC3    3101          ldhx    #user_scbr                  ; point to first parameter
 FB5C [04] 7E40      3102          mov     x+,count                    ; copy user SCI baud rate
 FB5E [04] 7E41      3103          mov     x+,temp_sp                  ; copy user Configuration Register 1
 FB60 [04] 7E42      3104          mov     x+,temp_sp+1                ; copy user Configuration Register 2
 FB62 [04] 7E43      3105          mov     x+,flash_first              ; copy first user Flash address MSB
 FB64 [04] 7E44      3106          mov     x+,flash_first+1            ; copy first user Flash address LSB
 FB66 [04] 7E45      3107          mov     x+,flash_last               ; copy last user Flash address MSB
 FB68 [04] 7E46      3108          mov     x+,flash_last+1             ; copy last user Flash address LSB
 FB6A [03] 450040    3109          ldhx    #count                      ; point to first parameter, now saved in RAM
 FB6D [02] 94        3110          txs                                 ; use SP to point to parameter list in RAM
                     3111  ;
                     3112  ;   Test the user SCI baud rate.  The user can override the default baud rate.
                     3113  ;
 FB6E [02] 86        3114          pula                                ; get user SCBR initial data
 FB6F [02] A1FF      3115          cmp     #flash_erased               ; check if it's erased
 FB71 [03] 2602      3116          bne     BootReset2                  ; skip if not
 FB73 [02] A612      3117          lda     #init_scbr                  ; else, force default value
                     3118  BootReset2:
 FB75 [03] B740      3119          sta     count                       ; save initial SCI baud rate
                     3120  ;
                     3121  ;   Program the write-once configuration registers.  The user can override the defaults.


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 29
MC68HC908GP32 User Bootloader


                     3122  ;
 FB77 [02] 86        3123          pula                                ; get user Configuration Register 1 initial data
 FB78 [02] A1FF      3124          cmp     #flash_erased               ; check if it's erased
 FB7A [03] 2602      3125          bne     BootReset3                  ; skip if not
 FB7C [02] A601      3126          lda     #init_config1               ; else, force default value
                     3127  BootReset3:
 FB7E [03] B71F      3128          sta     config1                     ; initialize Configuration Register 1
                     3129  ;
 FB80 [02] 86        3130          pula                                ; get user Configuration Register 2 initial data
 FB81 [02] A1FF      3131          cmp     #flash_erased               ; check if it's erased
 FB83 [03] 2602      3132          bne     BootReset4                  ; skip if not
 FB85 [02] A601      3133          lda     #init_config2               ; else, force default value
                     3134  BootReset4:
 FB87 [03] B71E      3135          sta     config2                     ; initialize Configuration Register 2
                     3136  ;
                     3137  ;   Program the first and last user Flash addresses.  The user can override the defaults.
                     3138  ;
 FB89 [02] 88        3139          pulx                                ; get first user Flash address LSB
 FB8A [02] 8A        3140          pulh                                ; get first user Flash address MSB
 FB8B [03] 65FFFF    3141          cphx    #$FFFF                      ; check if it's erased
 FB8E [03] 2608      3142          bne     BootReset5                  ; skip if not
 FB90 [02] A600      3143          lda     #{init_first&$FF}           ; else, get default first user address LSB
 FB92 [02] 87        3144          psha                                ;  save it
 FB93 [02] A680      3145          lda     #{init_first>8}             ;  and get default first user address MSB
 FB95 [02] 87        3146          psha                                ;  save it
 FB96 [02] A702      3147          ais     #2                          ; move stack pointer back
                     3148  ;
                     3149  BootReset5:
 FB98 [02] 88        3150          pulx                                ; get last user Flash address LSB
 FB99 [02] 8A        3151          pulh                                ; get last user Flash address MSB
 FB9A [03] 65FFFF    3152          cphx    #$FFFF                      ; check if it's erased
 FB9D [03] 2606      3153          bne     BootReset6                  ; skip if not
                     3154  ;        ldx     #{init_last&$FF}            ; else, get default last user address LSB
 FB9F [02] A600      3155          lda     #{init_last&$FF}            ; else, get default last user address LSB
 FBA1 [02] 87        3156          psha                                ;  save it
 FBA2 [02] A6FB      3157          lda     #{init_last>8}              ;  and get default last user address MSB
 FBA4 [02] 87        3158          psha                                ;  save it
                     3159  BootReset6:
                     3160  
                     3161  
                     3162  ;*  User Bootloader Entry  ==================================================================
                     3163  ;*
                     3164  ;*  The user can launch the bootloader from here.
                     3165  ;*
                     3166  BootResetUser:
 FBA5 [02] 9B        3167          sei                                 ; disable all interrupts
 FBA6 [04] C7FFFF    3168          sta     copctl                      ; clear the COP counter
 FBA9 [03] 4501ED    3169          ldhx    #init_stack+1               ; initialize
 FBAC [02] 94        3170          txs                                 ;  the stack pointer
                     3171  ;
                     3172  ;   Initialize the PLL CGM for 7.3728 MHz bus speed from 32.768 kHz crystal.
                     3173  ;
 FBAD [03] 45FB00    3174          ldhx    #bus7372800                 ; point to 7.3728 MHz parameters
 FBB0 [04] AD8B      3175          bsr     PLLset                      ; change bus speed
                     3176  ;
                     3177  ;   Take over and initialize the SCI.  The user can override the default baud rate.
                     3178  ;
 FBB2 [05] 4E4019    3179          mov     count,scbr                  ; initialize SCI baud rate
 FBB5 [04] 6E4013    3180          mov     #init_scc1,scc1             ; initialize SCI Control Register 1
 FBB8 [04] 6E0C14    3181          mov     #init_scc2,scc2             ; initialize SCI Control Register 2
                     3182  
                     3183  
                     3184  ;*  Main Bootloader Control Loop  ==========================================================
                     3185  ;*
                     3186  ;*  Bootloader program supports the following commands:
                     3187  ;*
                     3188  ;*      'X'  = Exit and execute user program via user reset vector
                     3189  ;*      'P'  = Program Flash via S-Records
                     3190  ;*      'W'  = Erase Flash (Wipe)
                     3191  ;*      'U'  = Upgrade Flash by erasing all user space, then programming via S-Records
                     3192  ;*      'H'  = Help
                     3193  ;*      '?'  = Help
                     3194  ;*
                     3195  ;*  Note: avoid using 'A' - 'F', as these are valid S-Record characters that could get
                     3196  ;*        misinterpreted.
                     3197  ;*
 FBBB                3198  cmd_exit:       equ     'X'                 ; Exit command
 FBBB                3199  cmd_program:    equ     'P'                 ; Program Flash command
 FBBB                3200  cmd_erase:      equ     'W'                 ; Erase Flash command (Wipe)
 FBBB                3201  cmd_upgrade:    equ     'U'                 ; Upgrade Flash command
 FBBB                3202  cmd_help:       equ     'H'                 ; Help command
 FBBB                3203  cmd_help1:      equ     $1F                 ; '?' = alternate Help command


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 30
MC68HC908GP32 User Bootloader


                     3204  ;
                     3205  Boot:
 FBBB [03] 45FD88    3206          ldhx    #msg_hello                  ; point to hello message
 FBBE [04] AD38      3207          bsr     PrintString                 ; output it
 FBC0 [05] CDFC6A    3208          jsr     GetChar                     ; get a character from the SCI
 FBC3 [02] A10D      3209          cmp     #ascii_CR                   ; check for ASCII carriage return
 FBC5 [03] 27F4      3210          beq     Boot                        ; just loop back if so
 FBC7 [04] AD8A      3211          bsr     PutChar                     ; else, echo character back
 FBC9 [02] A4DF      3212          and     #$DF                        ; convert to uppercase
                     3213  
                     3214  
                     3215  ;*  Execute User Program Command Check  =====================================================
                     3216  ;*
 FBCB [02] A158      3217          cmp     #cmd_exit                   ; check for Exit command
 FBCD [03] 2611      3218          bne     Boot2                       ; skip if not
 FBCF [04] C6FAFE    3219          lda     user_reset+1                ; else, get the MSB of the user reset vector
 FBD2 [02] A1FF      3220          cmp     #flash_erased               ; check if it's erased
 FBD4 [03] 2703      3221          beq     Boot1                       ; skip if not
 FBD6 [03] CCFAFD    3222          jmp     user_reset                  ; else, jump to user reset jump vector
                     3223  ;
                     3224  ;   Remain in the Bootloader if the MSB of the User Reset Jump Vector is erased.
                     3225  ;
                     3226  Boot1:
 FBD9 [03] 45FDE0    3227          ldhx    #msg_noreset                ; point to error message
 FBDC [04] AD1A      3228          bsr     PrintString                 ; output it
 FBDE [03] 20DB      3229          bra     Boot                        ; jump back to top
                     3230  
                     3231  
                     3232  ;*  Erase Flash Command Check  ==============================================================
                     3233  ;*
                     3234  Boot2:
 FBE0 [02] A157      3235          cmp     #cmd_erase                  ; check for Erase Flash command
 FBE2 [03] 2618      3236          bne     Boot3                       ; skip if not
 FBE4 [04] AD76      3237          bsr     EraseFlash                  ; else, go erase Flash
                     3238  ;
                     3239  ;   Common Bootloader command completion points.
                     3240  ;
                     3241  BootDone:
 FBE6 [03] 45FDB4    3242          ldhx    #msg_complete               ; point to operation complete message
                     3243  BootDone1:
 FBE9 [04] AD0D      3244          bsr     PrintString                 ; output it
                     3245  BootDone2:
 FBEB [03] 20CE      3246          bra     Boot                        ; jump back to top
                     3247  
                     3248  
                     3249  ;*  External PutString Subroutine  ==========================================================
                     3250  ;*
                     3251  ;*  This subroutine will output the null terminated string pointed to by X:A (which is a
                     3252  ;*  common implementation for pointer parameter passing used by HC08 C compilers) to the SCI.
                     3253  ;*
                     3254  ;*  C function prototype:
                     3255  ;*
                     3256  ;*      void PutString (char string*);
                     3257  ;*
                     3258  ;*  Calling convention:
                     3259  ;*
                     3260  ;*      ldx     #{string>8}                 ; get CGM parameter table address msb
                     3261  ;*      lda     #{string&$FF}               ; get CGM parameter table address lsb
                     3262  ;*      jsr     PutString                   ; go change the bus speed
                     3263  ;*
                     3264  ;*  Returns:    nothing
                     3265  ;*
                     3266  ;*  Changes:    H:X
                     3267  ;*
                     3268  PutString:
 FBED [02] 87        3269          psha                                ; save pointer lsb on stack
 FBEE [02] 89        3270          pshx                                ; save pointer msb on stack
 FBEF [02] 8A        3271          pulh                                ; initialize
 FBF0 [02] 88        3272          pulx                                ;  H:X points to data array
 FBF1 [03] 2005      3273          bra     PrintString                 ; go output string
                     3274  
                     3275  
                     3276  ;*  PrintString Subroutine  =================================================================
                     3277  ;*
                     3278  ;*  This subroutine will output the null teminated string pointed to by H:X to the SCI.
                     3279  ;*
                     3280  ;*  Calling convention:
                     3281  ;*
                     3282  ;*      ldhx    #string                     ; point to start of string
                     3283  ;*      jsr     PrintString                 ; go output it
                     3284  ;*
                     3285  ;*  Returns:    nothing


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 31
MC68HC908GP32 User Bootloader


                     3286  ;*
                     3287  ;*  Changes:    H:X
                     3288  ;*
                     3289  PrintString1:
 FBF3 [05] 0F16FD    3290          brclr   SCTE,scs1,PrintString1      ; wait until SCI transmitter is empty
 FBF6 [04] 7E18      3291          mov     x+,scdr                     ; output character to the SCI and advance pointer
                     3292  PrintString:
 FBF8 [02] 7D        3293          tst     ,x                          ; test string character
 FBF9 [03] 26F8      3294          bne     PrintString1                ; loop back if not null
 FBFB [04] 81        3295          rts                                 ; else, return
                     3296  
                     3297  
                     3298  ;*  Program Flash Command Check  ============================================================
                     3299  ;*
                     3300  Boot3:
 FBFC [02] A150      3301          cmp     #cmd_program                ; check for Program Flash command
 FBFE [03] 264A      3302          bne     Boot4                       ; skip if not
                     3303  ;
 FC00 [04] AD02      3304          bsr     BootProg                    ; go accept S19 records and program the Flash
 FC02 [03] 20B7      3305          bra     Boot                        ; return to top of control loop
                     3306  
                     3307  
                     3308  ;*  Program Flash Subroutine  ===============================================================
                     3309  ;*
                     3310  ;*  This subroutine will copy the Flash Program algorithm into RAM and execute it in
                     3311  ;*  conjunction with the S19 record retrieval to program the required Flash pages between
                     3312  ;*  address pointers "flash_first" and "flash_last".
                     3313  ;*
                     3314  ;*  Calling convention:
                     3315  ;*
                     3316  ;*      jsr     BootProg                    ; retrieve S19 records and program Flash
                     3317  ;*
                     3318  ;*  Returns:    nothing
                     3319  ;*
                     3320  ;*  Changes:    everything
                     3321  ;*
                     3322  BootProg:
 FC04 [03] 45004F    3323          ldhx    #ProgramRamSize             ; initialize pointer
                     3324  BootProg1:
 FC07 [04] D6FD38    3325          lda     Delay-1,x                   ; get program from Flash
 FC0A [04] D701EC    3326          sta     ram_exec-1,x                ; copy into RAM
 FC0D [03] 5BF8      3327          dbnzx   BootProg1                   ; decrement pointer and loop back until done
 FC0F [03] 45FDBF    3328          ldhx    #msg_waiting                ; point to waiting message
 FC12 [04] ADE4      3329          bsr     PrintString                 ; output it
                     3330  ;
                     3331  ;   Get S-Record from host.
                     3332  ;
                     3333  BootProg2:
 FC14 [02] 95        3334          tsx                                 ; get the Stack Pointer
 FC15 [04] 3541      3335          sthx    temp_sp                     ; save it temporarily
 FC17 [02] A7DC      3336          ais     #-36                        ; allocate stack space for data
 FC19 [04] AD58      3337          bsr     GetSRec                     ; get an S-Record
 FC1B [03] 2625      3338          bne     BootProg5                   ; indicate error if S-Record is invalid
 FC1D [02] 86        3339          pula                                ; get S-Record type
 FC1E [02] A130      3340          cmp     #'0'                        ; check for text header record type
 FC20 [03] 270B      3341          beq     BootProg3                   ; ignore and get next record
 FC22 [02] A139      3342          cmp     #'9'                        ; check for end record type
 FC24 [03] 270B      3343          beq     BootProg4                   ; indicate operation complete
 FC26 [02] A131      3344          cmp     #'1'                        ; check for data record type
 FC28 [03] 2618      3345          bne     BootProg5                   ; indicate error if S-Record is invalid
                     3346  ;
                     3347  ;   Program Flash.
                     3348  ;
 FC2A [05] CD01F8    3349          jsr     {ram_exec+ProgramRam}       ; execute Program Flash algorithm from RAM
                     3350  BootProg3:
 FC2D [02] A723      3351          ais     #35                         ; deallocate stack space
 FC2F [03] 20E3      3352          bra     BootProg2                   ; loop back for next S-Record
                     3353  ;
                     3354  BootProg4:
 FC31 [02] A723      3355          ais     #35                         ; deallocate stack space
 FC33 [05] 0B16B0    3356          brclr   SCRF,scs1,BootDone          ; skip if SCI receiver is empty
 FC36 [04] AD32      3357          bsr     GetChar                     ; else, clear last ASCII carriage return from SCI
 FC38 [05] 0B16AB    3358          brclr   SCRF,scs1,BootDone          ; skip if SCI receiver is empty
 FC3B [04] AD2D      3359          bsr     GetChar                     ; else, clear last ASCII line feed from the SCI
 FC3D [03] 45FDB4    3360          ldhx    #msg_complete               ; point to operation complete message
 FC40 [03] 2005      3361          bra     BootProg6                   ; go output it
                     3362  ;
                     3363  BootProg5:
 FC42 [02] A724      3364          ais     #36                         ; deallocate stack space
 FC44 [03] 45FDCE    3365          ldhx    #msg_error                  ; point to error message
                     3366  BootProg6:
 FC47 [04] ADAF      3367          bsr     PrintString                 ; output it


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 32
MC68HC908GP32 User Bootloader


 FC49 [04] 81        3368          rts                                 ; return
                     3369  
                     3370  
                     3371  ;*  Upgrade Flash Command Check  ============================================================
                     3372  ;*
                     3373  Boot4:
 FC4A [02] A155      3374          cmp     #cmd_upgrade                ; check for Upgrade Flash command
 FC4C [03] 2670      3375          bne     Boot5                       ; skip if not
                     3376  ;
 FC4E [03] 458000    3377          ldhx    #init_first                 ; force
 FC51 [04] 3543      3378          sthx    flash_first                 ;  first Flash address
 FC53 [03] 45FB00    3379          ldhx    #init_last                  ; force
 FC56 [04] 3545      3380          sthx    flash_last                  ;  last Flash address
 FC58 [04] AD02      3381          bsr     EraseFlash                  ; go erase Flash
 FC5A [03] 20A8      3382          bra     BootProg                    ; go program Flash
                     3383  
                     3384  
                     3385  ;*  Multiple Flash Page Erase Subroutine  ===================================================
                     3386  ;*
                     3387  ;*  This subroutine will copy the Flash Erase algorithm into RAM and execute it to erase
                     3388  ;*  all pages between address pointers "flash_first" and "flash_last".
                     3389  ;*
                     3390  ;*  Calling convention:
                     3391  ;*
                     3392  ;*      ldhx    #init_first                 ; initialize
                     3393  ;*      sthx    flash_first                 ;  first Flash address
                     3394  ;*      ldhx    #init_last                  ; initialize
                     3395  ;*      sthx    flash_last                  ;  last Flash address
                     3396  ;*      jsr     EraseFlash                  ; go erase flash
                     3397  ;*
                     3398  ;*  Returns:    nothing
                     3399  ;*
                     3400  ;*  Changes:    everything
                     3401  ;*
                     3402  EraseFlash:
 FC5C [03] 45003B    3403          ldhx    #EraseRamSize               ; initialize pointer
                     3404  EraseFlash1:
 FC5F [04] D6FD08    3405          lda     MassErase-1,x               ; get program from Flash
 FC62 [04] D701EC    3406          sta     ram_exec-1,x                ; copy into RAM
 FC65 [03] 5BF8      3407          dbnzx   EraseFlash1                 ; decrement pointer and loop back until done
 FC67 [03] CC01ED    3408          jmp     ram_exec                    ; execute Flash Mass Erase algorithm from RAM
                     3409  
                     3410  
                     3411  ;*  GetChar Subroutine  =====================================================================
                     3412  ;*
                     3413  ;*  This subroutine will wait forever for a character to be received by the SCI and then
                     3414  ;*  returns with that character in ACC.  No error checking is performed.  Note that this
                     3415  ;*  is the primary loop where the COP counter is cleared.
                     3416  ;*
                     3417  ;*  C function prototype:
                     3418  ;*
                     3419  ;*      char GetChar (void);
                     3420  ;*
                     3421  ;*  Calling convention:
                     3422  ;*
                     3423  ;*      jsr     GetChar                     ; get a character from the SCI
                     3424  ;*
                     3425  ;*  Returns:
                     3426  ;*      ACC= data
                     3427  ;*
                     3428  GetChar:
 FC6A [04] C7FFFF    3429          sta     copctl                      ; clear the COP counter
 FC6D [05] 0B16FA    3430          brclr   SCRF,scs1,GetChar           ; wait forever until SCI receiver is full
 FC70 [03] B618      3431          lda     scdr                        ; get data
 FC72 [04] 81        3432          rts                                 ; return
                     3433  
                     3434  
                     3435  ;*  GetSRec Subroutine  =====================================================================
                     3436  ;*
                     3437  ;*  This subroutine will retrieve data in S19 record format via the SCI.
                     3438  ;*
                     3439  ;*  Calling convention:
                     3440  ;*
                     3441  ;*      ais     #-buffer_length             ; allocate stack space for data
                     3442  ;*      jsr     GetSRec                     ; go get S-record data
                     3443  ;*
                     3444  ;*  Returns:    CCRZ= 1 if valid S-Record retrieved.  Otherwise, CCRZ= 0.
                     3445  ;*              S-Record Type at SP+1     (1 byte)
                     3446  ;*              S-Record Size at SP+2     (1 byte)
                     3447  ;*              S-Record Address at SP+3  (2 bytes)
                     3448  ;*              S-Record Data at SP+5     (up to 32 bytes, typically)
                     3449  ;*


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 33
MC68HC908GP32 User Bootloader


                     3450  ;*              |                |    <-sp (after local space allocation)
                     3451  ;*      H:X->   | SRecCount      |
                     3452  ;*              | SRecChkSum     |    <-sp (when called)
                     3453  ;*              | ReturnAddr msb |
                     3454  ;*              | ReturnAddr lsb |    <-sp (upon return)
                     3455  ;*              | SRecType       |
                     3456  ;*              | SRecSize       |
                     3457  ;*      H:X->   | SRecAddr msb   |
                     3458  ;*              | SRecAddr lsb   |
                     3459  ;*              | SRecData 00    |
                     3460  ;*              | SRecData 01    |  etc..
                     3461  ;*
                     3462  ;*  Changes:    everything
                     3463  ;*
 FC73                3464  SRecCount:      equ     1                   ; stack pointer offset for S-Record Counter
 FC73                3465  SRecChkSum:     equ     2                   ; stack pointer offset for S-Record Check Sum
 FC73                3466  SRecType:       equ     5                   ; stack pointer offset for S-Record Type
 FC73                3467  SRecSize:       equ     6                   ; stack pointer offset for S-Record Size
 FC73                3468  SRecAddr:       equ     7                   ; stack pointer offset for S-Record Address
 FC73                3469  SRedData:       equ     8                   ; stack pointer offset for S-Record Data
                     3470  ;
                     3471  GetSRec:
 FC73 [02] A7FE      3472          ais     #-2                         ; allocate local variable space
 FC75 [04] 9E6F06    3473          clr     SRecSize,sp                 ; initialize S-Record size
                     3474  GetSRec1:
 FC78 [04] ADF0      3475          bsr     GetChar                     ; get a character from the SCI
 FC7A [02] A10D      3476          cmp     #ascii_CR                   ; check for ASCII carriage return
 FC7C [03] 2602      3477          bne     GetSRec1a                   ; just loop back if so
 FC7E [02] A60A      3478          lda     #ascii_LF                   ; get ASCII line feed
                     3479  GetSRec1a:
 FC80 [02] A153      3480          cmp     #'S'                        ; check for start of record character
 FC82 [03] 26F4      3481          bne     GetSRec1                    ; loop back if not
 FC84 [04] ADE4      3482          bsr     GetChar                     ; else, get next character from the SCI
 FC86 [02] A130      3483          cmp     #'0'                        ; check for header record type
 FC88 [03] 27EE      3484          beq     GetSRec1                    ; loop back if so
 FC8A [02] A139      3485          cmp     #'9'                        ; else, check for end record type
 FC8C [03] 2704      3486          beq     GetSRec2                    ; continue if so
 FC8E [02] A131      3487          cmp     #'1'                        ; else, check for data record type
 FC90 [03] 26E6      3488          bne     GetSRec1                    ; loop back if not
                     3489  GetSRec2:
 FC92 [04] 9EE705    3490          sta     SRecType,sp                 ; save S-Record type
 FC95 [04] AD3B      3491          bsr     GetHexByte                  ; get the S-Record length
 FC97 [03] 2622      3492          bne     GetSRec4                    ; exit if not a valid hex byte
 FC99 [04] 9EE701    3493          sta     SRecCount,sp                ; initialize S-Record counter
 FC9C [04] 9EE702    3494          sta     SRecChkSum,sp               ; initialize S-Record check sum
 FC9F [02] A003      3495          sub     #3                          ; adjust for address and checksum
 FCA1 [04] 9EE706    3496          sta     SRecSize,sp                 ; save S-Record size
 FCA4 [02] 95        3497          tsx                                 ; use H:X as data stack frame pointer
 FCA5 [02] AF06      3498          aix     #{SRecAddr-1}               ; adjust so pointer starts at S-Record Address
                     3499  GetSRec3:
 FCA7 [04] AD29      3500          bsr     GetHexByte                  ; get next S-Record hex byte
 FCA9 [03] 2610      3501          bne     GetSRec4                    ; exit if not a valid hex byte
 FCAB [02] F7        3502          sta     ,x                          ; save data in stack frame
 FCAC [04] 9EEB02    3503          add     SRecChkSum,sp               ; add data to check sum
 FCAF [04] 9EE702    3504          sta     SRecChkSum,sp               ; save new check sum
 FCB2 [02] AF01      3505          aix     #1                          ; move data stack frame pointer
 FCB4 [06] 9E6B01EF  3506          dbnz    SRecCount,sp,GetSRec3       ; loop back until all data has been received
 FCB8 [05] 9E6C02    3507          inc     SRecChkSum,sp               ; final calculation zeros check sum if it's okay
                     3508  GetSRec4:
 FCBB [02] A702      3509          ais     #2                          ; deallocate local variables
 FCBD [04] 81        3510          rts                                 ; return
                     3511  
                     3512  
                     3513  ;*  Help Command Response  ==================================================================
                     3514  ;*
                     3515  Boot5:
 FCBE [02] A148      3516          cmp     #cmd_help                   ; check for Help command
 FCC0 [03] 2704      3517          beq     Boot6                       ; continue if so
 FCC2 [02] A11F      3518          cmp     #cmd_help1                  ; check for alternate Help command
 FCC4 [03] 2606      3519          bne     Boot7                       ; skip if not
                     3520  boot6:
 FCC6 [03] 45FD90    3521          ldhx    #msg_help                   ; point to Help command message
 FCC9 [03] CCFBE9    3522          jmp     BootDone1                   ; go output it
                     3523  
                     3524  
                     3525  ;*  Unknown Command Response  ===============================================================
                     3526  ;*
                     3527  Boot7:
 FCCC [03] 45FDD7    3528          ldhx    #msg_what                   ; point to unknown command message
 FCCF [03] CCFBE9    3529          jmp     BootDone1                   ; go output it
                     3530  
                     3531  


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 34
MC68HC908GP32 User Bootloader


                     3532  ;*  GetHexByte Subroutine  ==================================================================
                     3533  ;*
                     3534  ;*  This subroutine retrieves two ASCII bytes via the SCI and converts (packs) them into one
                     3535  ;*  hex byte, which is returned in ACC.
                     3536  ;*
                     3537  ;*  Calling convention:
                     3538  ;*
                     3539  ;*      jsr     GetHexByte
                     3540  ;*
                     3541  ;*  Returns:    CCRZ= 1 if valid hex byte retrieved.  Otherwise, CCRZ= 0.
                     3542  ;*              ACC= data
                     3543  ;*
                     3544  ;*  Changes:    ACC
                     3545  ;*
                     3546  GetHexByte:
 FCD2 [04] AD96      3547          bsr     GetChar                     ; get msb character from the SCI
 FCD4 [04] AD20      3548          bsr     IsHex                       ; check if valid ASCII hex character
 FCD6 [03] 2614      3549          bne     GetHexByte2                 ; exit if not
 FCD8 [04] AD13      3550          bsr     ToHex                       ; convert ASCII hex character to hex value
 FCDA [03] 62        3551          nsa                                 ; swap lower nibble up
 FCDB [02] 87        3552          psha                                ; save temporarily
 FCDC [05] CDFC6A    3553          jsr     GetChar                     ; get lsb character from the SCI
 FCDF [04] AD15      3554          bsr     IsHex                       ; check if valid ASCII hex character
 FCE1 [03] 2607      3555          bne     GetHexByte1                 ; exit if not
 FCE3 [04] AD08      3556          bsr     ToHex                       ; convert ASCII hex character to hex value
 FCE5 [04] 9EEB01    3557          add     1,sp                        ; combine msb and lsb nibbles
 FCE8 [02] A500      3558          bit     #0                          ; CCRZ= 1
                     3559  GetHexByte1:
 FCEA [02] A701      3560          ais     #1                          ; deallocate local variable
                     3561  GetHexByte2:
 FCEC [04] 81        3562          rts                                 ; return
                     3563  
                     3564  
                     3565  ;*  ToHex Subroutine  =======================================================================
                     3566  ;*
                     3567  ;*  This subroutine converts the ASCII hex value passed in ACC to a binary hex value.
                     3568  ;*
                     3569  ;*  Calling convention:
                     3570  ;*
                     3571  ;*      lda     data
                     3572  ;*      jsr     ToHex
                     3573  ;*
                     3574  ;*  Returns:    ACC= data.
                     3575  ;*
                     3576  ;*  Changes:    ACC
                     3577  ;*
                     3578  ToHex:
 FCED [02] A030      3579          sub     #'0'                        ; adjust first by subtracting '0'
 FCEF [02] A109      3580          cmp     #9                          ; check if value was between '0' to '9'
 FCF1 [03] 2302      3581          bls     ToHex1                      ; exit if so
 FCF3 [02] A007      3582          sub     #7                          ; else, adjust for value between 'A' to 'F'
                     3583  ToHex1:
 FCF5 [04] 81        3584          rts                                 ; return
                     3585  
                     3586  
                     3587  ;*  IsHex Subroutine  =======================================================================
                     3588  ;*
                     3589  ;*  This subroutine checks if the value passed in ACC is a valid ASCII hex character within
                     3590  ;*  within the ranges of '0' to '9' or 'A' to 'F'.  Note that the range 'a' to 'f' is not
                     3591  ;*  checked.
                     3592  ;*
                     3593  ;*  Calling convention:
                     3594  ;*
                     3595  ;*      lda     data
                     3596  ;*      jsr     IsHex
                     3597  ;*
                     3598  ;*  Returns:    CCRZ= 1 if data is a valid hex character.  Otherwise, CCRZ= 0.
                     3599  ;*
                     3600  ;*  Changes:    nothing
                     3601  ;*
                     3602  IsHex:
 FCF6 [02] A130      3603          cmp     #'0'                        ; check value against '0'
 FCF8 [03] 250E      3604          blo     IsntHex                     ; not hex if lower
 FCFA [02] A139      3605          cmp     #'9'                        ; check value against '9'
 FCFC [03] 2308      3606          bls     IsHex1                      ; is hex if lower
 FCFE [02] A141      3607          cmp     #'A'                        ; check value against 'A'
 FD00 [03] 2506      3608          blo     IsntHex                     ; not hex if lower
 FD02 [02] A146      3609          cmp     #'F'                        ; check value against 'F'
 FD04 [03] 2202      3610          bhi     IsntHex                     ; not hex if higher
                     3611  IsHex1:
 FD06 [02] A500      3612          bit     #0                          ; CCRZ= 1
                     3613  IsntHex:


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 35
MC68HC908GP32 User Bootloader


 FD08 [04] 81        3614          rts                                 ; return
                     3615  
                     3616  
                     3617  ;*  Flash Mass Erase Subroutine  ============================================================
                     3618  ;*
                     3619  ;*  This subroutine performs multiple Page Erase operations in order to erase the application
                     3620  ;*  space Flash memory between "flash_first" and "flash_last".  This subroutine has been
                     3621  ;*  tuned for a bus speed of 7.3728 MHz.
                     3622  ;*  This subroutine is copied into and executed from RAM.
                     3623  ;*
                     3624  MassErase:
 FD09 [04] 5545      3625          ldhx    flash_last                  ; initialize pointer to last Flash memory address
 FD0B [03] 2023      3626          bra     MassErase2                  ; go move pointer before erasing Flash
                     3627  MassErase1:
                     3628  ;
                     3629  ;   Set ERASE, read the Flash Block Protect Register and write any data into Flash page.
                     3630  ;
 FD0D [02] A602      3631          lda     #{ERASE}                    ; set ERASE control bit
 FD0F [04] C7FE08    3632          sta     flcr                        ;  in Flash Control Register
 FD12 [04] C6FF7E    3633          lda     flbpr                       ; read from Flash Block Protect Register
 FD15 [02] F7        3634          sta     ,x                          ; write any data to address within page
                     3635  ;
                     3636  ;   Wait for >10us, then set HVEN.
                     3637  ;
 FD16 [02] A601      3638          lda     #1                          ; wait
 FD18 [04] AD1F      3639          bsr     delay                       ;  for 11.7us
 FD1A [02] A60A      3640          lda     #{ERASE | HVEN}             ; set HVEN control bit
 FD1C [04] C7FE08    3641          sta     flcr                        ;  in Flash Control Register
                     3642  ;
                     3643  ;   Wait for >1ms, then clear ERASE.
                     3644  ;
 FD1F [02] A664      3645          lda     #100                        ; wait
 FD21 [04] AD16      3646          bsr     delay                       ;  for 1.005ms
 FD23 [02] A608      3647          lda     #{HVEN}                     ; clear ERASE control bit
 FD25 [04] C7FE08    3648          sta     flcr                        ;  in Flash Control Register
                     3649  ;
                     3650  ;   Wait for >5us, then clear HVEN.
                     3651  ;
 FD28 [02] A601      3652          lda     #1                          ; wait
 FD2A [04] AD0D      3653          bsr     delay                       ;  for 11.7us
 FD2C [01] 4F        3654          clra                                ; clear HVEN control bit
 FD2D [04] C7FE08    3655          sta     flcr                        ;  in Flash Control Register
                     3656  ;
                     3657  ;   Advance pointer and repeat until finished.
                     3658  ;
                     3659  MassErase2:
 FD30 [02] AFC0      3660          aix     #-64                        ; move pointer back
 FD32 [02] AFC0      3661          aix     #-64                        ;  by one complete erase page
 FD34 [04] 7543      3662          cphx    flash_first                 ; check if finished
 FD36 [03] 22D5      3663          bhi     MassErase1                  ; loop back if not
                     3664  ;
 FD38 [04] 81        3665          rts                                 ; return
                     3666  
                     3667  
                     3668  ;*  Delay Subroutine  =======================================================================
                     3669  ;*
                     3670  ;*  This subroutine performs a simple software delay loop based upon the value passed in ACC.
                     3671  ;*  The following timing calculation applies:
                     3672  ;*
                     3673  ;*              delay = ((ACC * 74) + 12) (tcyc)
                     3674  ;*
                     3675  ;*  Calling convention:
                     3676  ;*
                     3677  ;*      lda     data
                     3678  ;*      jsr     delay
                     3679  ;*
                     3680  ;*  Returns:    nothing
                     3681  ;*
                     3682  ;*  Changes:    ACC
                     3683  ;*
                     3684  Delay:
 FD39 [02] 87        3685          psha                                ; [2] save outer delay loop parameter
                     3686  Delay1:
 FD3A [02] A616      3687          lda     #22                         ; [2] initialize inner delay loop counter
                     3688  Delay2:
 FD3C [03] 4BFE      3689          dbnza   Delay2                      ; [3] decrement inner delay loop counter
 FD3E [06] 9E6B01F8  3690          dbnz    1,sp,Delay1                 ; [6] decrement outer delay loop counter
 FD42 [02] 86        3691          pula                                ; [2] deallocate local variable
 FD43 [04] 81        3692          rts                                 ; [4] return
                     3693  
 FD44                3694  EraseRamSize:   equ     {*-MassErase}
 FD44                3695  ProgramRam:     equ     {*-Delay}


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 36
MC68HC908GP32 User Bootloader


                     3696  
                     3697  
                     3698  ;*  Flash Program Subroutine  ===============================================================
                     3699  ;*
                     3700  ;*  This subroutine controls the Flash programming sequence.  A stack frame data block is
                     3701  ;*  passed to it in the format shown below.  This subroutine has been tuned for a bus speed
                     3702  ;*  of 7.3728 MHz.
                     3703  ;*  This subroutine is copied into and executed from RAM.
                     3704  ;*
                     3705  ;*              |                |    <-sp (when called)
                     3706  ;*              | ReturnAddr msb |
                     3707  ;*              | ReturnAddr lsb |    <-sp (upon return)
                     3708  ;*              | SRecSize       |
                     3709  ;*              | SRecAddr msb   |
                     3710  ;*              | SRecAddr lsb   |
                     3711  ;*              | SRecData 00    |
                     3712  ;*              | SRecData 01    |  etc..
                     3713  ;*
                     3714  FlashProgram:
 FD44 [02] 95        3715          tsx                                 ; get the Stack Pointer
 FD45 [04] 3541      3716          sthx    temp_sp                     ; save it temporarily
                     3717  ;
                     3718  ;   Get S-Record size and use the Stack Pointer as the data source pointer.
                     3719  ;
 FD47 [02] A702      3720          ais     #2                          ; SP points to SRecSize
 FD49 [02] 86        3721          pula                                ; get SRecSize
 FD4A [03] B740      3722          sta     count                       ; save it temporarily
                     3723  ;
                     3724  ;   Establish H:X as the destination pointer.
                     3725  ;
 FD4C [02] 8A        3726          pulh                                ; get destination address msb
 FD4D [02] 88        3727          pulx                                ; get destination address lsb
                     3728  
                     3729  FlashProgram1:
 FD4E [04] 7543      3730          cphx    flash_first                 ; check against minimum address
 FD50 [03] 252D      3731          blo     FlashProgram2               ; skip if lower
 FD52 [04] 7545      3732          cphx    flash_last                  ; check against maximum address
 FD54 [03] 2429      3733          bhs     FlashProgram2               ; skip if the same or higher
                     3734  ;
                     3735  ;   Set PGM, read the Flash Block Protect Register and write anywhere in desired Flash row.
                     3736  ;
 FD56 [02] A601      3737          lda     #{PGM}                      ; set PGM control bit
 FD58 [04] C7FE08    3738          sta     flcr                        ;  in Flash Control Register
 FD5B [04] C6FF7E    3739          lda     flbpr                       ; read from Flash Block Protect Register
 FD5E [02] F7        3740          sta     ,x                          ; write any data to first Flash address
                     3741  ;
                     3742  ;   Wait for >10us, then set HVEN.
                     3743  ;
 FD5F [02] A601      3744          lda     #1                          ; wait
 FD61 [04] ADD6      3745          bsr     delay                       ;  for 11.7us
 FD63 [02] A609      3746          lda     #{PGM | HVEN}               ; set HVEN control bit
 FD65 [04] C7FE08    3747          sta     flcr                        ;  in Flash Control Register
                     3748  ;
                     3749  ;   Wait for >5us.
                     3750  ;
 FD68 [02] A601      3751          lda     #1                          ; wait
 FD6A [04] ADCD      3752          bsr     delay                       ;  for 11.7us
                     3753  ;
                     3754  ;   Write data to Flash and wait for 30 - 40us.
                     3755  ;
 FD6C [02] 86        3756          pula                                ; get S-Record data
 FD6D [02] F7        3757          sta     ,x                          ; write data to Flash
 FD6E [02] A603      3758          lda     #3                          ; wait
 FD70 [04] ADC7      3759          bsr     delay                       ;  for 31.7us
                     3760  ;
                     3761  ;   Clear PGM.
                     3762  ;
 FD72 [02] A608      3763          lda     #{HVEN}                     ; clear PGM
 FD74 [04] C7FE08    3764          sta     flcr                        ;  in Flash Control Register
                     3765  ;
                     3766  ;   Wait for >5us, then clear HVEN.
                     3767  ;
 FD77 [02] A601      3768          lda     #1                          ; wait
 FD79 [04] ADBE      3769          bsr     delay                       ;  for 11.7us
 FD7B [01] 4F        3770          clra                                ; clear HVEN control bit
 FD7C [04] C7FE08    3771          sta     flcr                        ;  in Flash Control Register
                     3772  ;
                     3773  ;   Advance destination pointer and data counter.
                     3774  ;
                     3775  FlashProgram2:
 FD7F [02] AF01      3776          aix     #1                          ; advance destination pointer
 FD81 [05] 3B40CA    3777          dbnz    count,FlashProgram1         ; decrement counter and loop back if not done.


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 37
MC68HC908GP32 User Bootloader


                     3778  ;
 FD84 [04] 5541      3779          ldhx    temp_sp                     ; restore
 FD86 [02] 94        3780          txs                                 ;  Stack Pointer
 FD87 [04] 81        3781          rts                                 ; return
                     3782  
 FD88                3783  ProgramRamSize: equ     {*-Delay}
                     3784  
                     3785  
                     3786  ;*  Messages  ===================================================================================
                     3787  ;*
 FD88                3788  ascii_CR:       equ     $0D                 ; ASCII carriage return
 FD88                3789  ascii_LF:       equ     $0A                 ; ASCII line feed
                     3790  ;
 FD88      0D0A426F  3791  msg_hello:      db      ascii_CR,ascii_LF,'Boot>',0
           6F743E00 
 FD90      20202850  3792  msg_help:       db      '  (P)rogram (W)ipe (U)pgrade e(X)it',0
           29726F67 
           72616D20 
           28572969 
           70652028 
           55297067 
           72616465 
           20652858 
           29697400 
                     3793  ;
 FDB4      2020436F  3794  msg_complete:   db      '  Complete',0
           6D706C65 
           746500 
 FDBF      202D2077  3795  msg_waiting:    db      ' - waiting ...',0
           61697469 
           6E67202E 
           2E2E00 
 FDCE      202D2065  3796  msg_error:      db      ' - error',0
           72726F72 
           00 
 FDD7      202D2077  3797  msg_what:       db      ' - what?',0
           6861743F 
           00 
 FDE0      202D2052  3798  msg_noreset:    db      ' - Reset Vector Invalid',0
           65736574 
           20566563 
           746F7220 
           496E7661 
           6C696400 
                     3799  
                     3800  ;
                     3801  ;   Last location not to exceed $FDFF
                     3802  ;
                     3803  BootEnd:
                     3804  
                     3805  
                     3806  ;*  Vectors  ************************************************************************************
                     3807  ;*
 FFDC                3808          org     vec_timebase                ; Timebase vector
 FFDC      FACA      3809          dw      user_timebase
 FFDE                3810          org     vec_adc                     ; ADC vector
 FFDE      FACD      3811          dw      user_ADC
 FFE0                3812          org     vec_kbd                     ; Keyboard vector
 FFE0      FAD0      3813          dw      user_keyboard
 FFE2                3814          org     vec_scitx                   ; SCI transmit vector
 FFE2      FAD3      3815          dw      user_SCItx
 FFE4                3816          org     vec_scirx                   ; SCI receive vector
 FFE4      FAD6      3817          dw      user_SCIrx
 FFE6                3818          org     vec_scierr                  ; SCI error vector
 FFE6      FAD9      3819          dw      user_SCIerr
 FFE8                3820          org     vec_spitx                   ; SPI transmit vector
 FFE8      FADC      3821          dw      user_SPItx
 FFEA                3822          org     vec_spirx                   ; SPI receive vector
 FFEA      FADF      3823          dw      user_SPIrx
 FFEC                3824          org     vec_tim2ov                  ; Timer 2 overflow vector
 FFEC      FAE2      3825          dw      user_Tim2Ov
 FFEE                3826          org     vec_tim2ch1                 ; Timer 2 channel 1 vector
 FFEE      FAE5      3827          dw      user_Tim2Ch1
 FFF0                3828          org     vec_tim2ch0                 ; Timer 2 channel 0 vector
 FFF0      FAE8      3829          dw      user_Tim2Ch0
 FFF2                3830          org     vec_tim1ov                  ; Timer 1 oveflow vector
 FFF2      FAEB      3831          dw      user_Tim1Ov
 FFF4                3832          org     vec_tim1ch1                 ; Timer 1 channel 1 vector
 FFF4      FAEE      3833          dw      user_Tim1Ch1
 FFF6                3834          org     vec_tim1ch0                 ; Timer 1 channel 0 vector
 FFF6      FAF1      3835          dw      user_Tim1Ch0
 FFF8                3836          org     vec_pll                     ; PLL vector


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 38
MC68HC908GP32 User Bootloader


 FFF8      FAF4      3837          dw      user_PLL
 FFFA                3838          org     vec_irq                     ; IRQ vector
 FFFA      FAF7      3839          dw      user_IRQ
 FFFC                3840          org     vec_swi                     ; SWI vector
 FFFC      FAFA      3841          dw      user_SWI
 FFFE                3842          org     vec_reset                   ; Reset vector
 FFFE      FB08      3843          dw      BootReset
                     3844  
                     3845  
                     3846  ;*  Flash Block Protect Register  ***************************************************************
                     3847  ;*
 FF7E                3848          org     flbpr
 FF7E      F6        3849          db      flash_protect
                     3850  
 FF7F                3851          end
                     3852  
                     3853  ;****************************************************************************
                     3854  ; - Lookup Tables
                     3855  ;****************************************************************************
                     3856  
 F000                3857       org     $F000     ; $F000 to $F600 (61440 to 62976)
                     3858  
 F000                3859       include "BatVolt.inc"   ; table=BatVolt:,    offset=BAT,  result=Volts
                     3860  BatVolt:
 F000      00        3861       DB      0T       ; x=000        ;=0.000v        ;=sens fail
 F001      01        3862       DB      1T       ; x=001        ;=0.020v
 F002      02        3863       DB      2T       ; x=002        ;=0.039v
 F003      03        3864       DB      3T       ; x=003        ;=0.059v
 F004      05        3865       DB      5T       ; x=004        ;=0.078v
 F005      06        3866       DB      6T       ; x=005        ;=0.098v
 F006      07        3867       DB      7T       ; x=006        ;=0.118v
 F007      08        3868       DB      8T       ; x=007        ;=0.137v
 F008      09        3869       DB      9T       ; x=008        ;=0.157v
 F009      0B        3870       DB      11T      ; x=009        ;=0.176v
 F00A      0C        3871       DB      12T      ; x=010        ;=0.196v
 F00B      0D        3872       DB      13T      ; x=011        ;=0.216v
 F00C      0E        3873       DB      14T      ; x=012        ;=0.235v
 F00D      0F        3874       DB      15T      ; x=013        ;=0.255v
 F00E      11        3875       DB      17T      ; x=014        ;=0.275v
 F00F      12        3876       DB      18T      ; x=015        ;=0.294v
 F010      13        3877       DB      19T      ; x=016        ;=0.314v
 F011      14        3878       DB      20T      ; x=017        ;=0.333v
 F012      15        3879       DB      21T      ; x=018        ;=0.353v
 F013      16        3880       DB      22T      ; x=019        ;=0.373v
 F014      18        3881       DB      24T      ; x=020        ;=0.392v
 F015      19        3882       DB      25T      ; x=021        ;=0.412v
 F016      1A        3883       DB      26T      ; x=022        ;=0.431v
 F017      1B        3884       DB      27T      ; x=023        ;=0.451v
 F018      1C        3885       DB      28T      ; x=024        ;=0.471v
 F019      1D        3886       DB      29T      ; x=025        ;=0.490v
 F01A      1F        3887       DB      31T      ; x=026        ;=0.510v
 F01B      20        3888       DB      32T      ; x=027        ;=0.529v
 F01C      21        3889       DB      33T      ; x=028        ;=0.549v
 F01D      22        3890       DB      34T      ; x=029        ;=0.569v
 F01E      23        3891       DB      35T      ; x=030        ;=0.588v
 F01F      24        3892       DB      36T      ; x=031        ;=0.608v
 F020      26        3893       DB      38T      ; x=032        ;=0.627v
 F021      27        3894       DB      39T      ; x=033        ;=0.647v
 F022      28        3895       DB      40T      ; x=034        ;=0.667v
 F023      29        3896       DB      41T      ; x=035        ;=0.686v
 F024      2A        3897       DB      42T      ; x=036        ;=0.706v
 F025      2C        3898       DB      44T      ; x=037        ;=0.725v
 F026      2D        3899       DB      45T      ; x=038        ;=0.745v
 F027      2E        3900       DB      46T      ; x=039        ;=0.765v
 F028      2F        3901       DB      47T      ; x=040        ;=0.784v
 F029      30        3902       DB      48T      ; x=041        ;=0.804v
 F02A      31        3903       DB      49T      ; x=042        ;=0.824v
 F02B      33        3904       DB      51T      ; x=043        ;=0.843v
 F02C      34        3905       DB      52T      ; x=044        ;=0.863v
 F02D      35        3906       DB      53T      ; x=045        ;=0.882v
 F02E      36        3907       DB      54T      ; x=046        ;=0.902v
 F02F      37        3908       DB      55T      ; x=047        ;=0.922v
 F030      38        3909       DB      56T      ; x=048        ;=0.941v
 F031      3A        3910       DB      58T      ; x=049        ;=0.961v
 F032      3B        3911       DB      59T      ; x=050        ;=0.980v
 F033      3C        3912       DB      60T      ; x=051        ;=1.000v
 F034      3D        3913       DB      61T      ; x=052        ;=1.020v
 F035      3E        3914       DB      62T      ; x=053        ;=1.039v
 F036      40        3915       DB      64T      ; x=054        ;=1.059v
 F037      41        3916       DB      65T      ; x=055        ;=1.078v
 F038      42        3917       DB      66T      ; x=056        ;=1.096v
 F039      43        3918       DB      67T      ; x=057        ;=1.118v


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 39
MC68HC908GP32 User Bootloader


 F03A      44        3919       DB      68T      ; x=058        ;=1.137v
 F03B      45        3920       DB      69T      ; x=059        ;=1.157v
 F03C      47        3921       DB      71T      ; x=060        ;=1.176v
 F03D      48        3922       DB      72T      ; x=061        ;=1,196v
 F03E      49        3923       DB      73T      ; x=062        ;=1,216v
 F03F      4A        3924       DB      74T      ; x=063        ;=1.235v
 F040      4B        3925       DB      75T      ; x=064        ;=1.255v
 F041      4D        3926       DB      77T      ; x=065        ;=1.275v
 F042      4E        3927       DB      78T      ; x=066        ;=1.294v
 F043      4F        3928       DB      79T      ; x=067        ;=1.314v
 F044      50        3929       DB      80T      ; x=068        ;=1.333v
 F045      51        3930       DB      81T      ; x=069        ;=1.353v
 F046      52        3931       DB      82T      ; x=070        ;=1.373v
 F047      54        3932       DB      84T      ; x=071        ;=1.392v
 F048      55        3933       DB      85T      ; x=072        ;=1.412v
 F049      56        3934       DB      86T      ; x=073        ;=1.431v
 F04A      57        3935       DB      87T      ; x=074        ;=1.451v
 F04B      58        3936       DB      88T      ; x=075        ;=1.471v
 F04C      59        3937       DB      89T      ; x=076        ;=1.490v
 F04D      5B        3938       DB      91T      ; x=077        ;=1.510v
 F04E      5C        3939       DB      92T      ; x=078        ;=1.529v
 F04F      5D        3940       DB      93T      ; x=079        ;=1.549v
 F050      5E        3941       DB      94T      ; x=080        ;=1.569v
 F051      5F        3942       DB      95T      ; x=081        ;=1.588v
 F052      60        3943       DB      96T      ; x=082        ;=1.608v
 F053      62        3944       DB      98T      ; x=083        ;=1.627v
 F054      63        3945       DB      99T      ; x=084        ;=1.647v
 F055      64        3946       DB      100T     ; x=085        ;=1.667v
 F056      65        3947       DB      101T     ; x=086        ;=1.686v
 F057      66        3948       DB      102T     ; x=087        ;=1.706v
 F058      68        3949       DB      104T     ; x=088        ;=1.725v
 F059      69        3950       DB      105T     ; x=089        ;=1.745v
 F05A      6A        3951       DB      106T     ; x=090        ;=1.765v
 F05B      6B        3952       DB      107T     ; x=091        ;=1.784v
 F05C      6C        3953       DB      108T     ; x=092        ;=1.804v
 F05D      6D        3954       DB      109T     ; x=093        ;=1.824v
 F05E      6F        3955       DB      111T     ; x=094        ;=1.843v
 F05F      70        3956       DB      112T     ; x=095        ;=1.863v
 F060      71        3957       DB      113T     ; x=096        ;=1.882v
 F061      72        3958       DB      114T     ; x=097        ;=1.902v
 F062      73        3959       DB      115T     ; x=098        ;=1.922v
 F063      74        3960       DB      116T     ; x=099        ;=1.941v
 F064      76        3961       DB      118T     ; x=100        ;=1.961v
 F065      77        3962       DB      119T     ; x=101        ;=1.980v
 F066      78        3963       DB      120T     ; x=102        ;=2.000v
 F067      79        3964       DB      121T     ; x=103        ;=2.020v
 F068      7A        3965       DB      122T     ; x=104        ;=2.039v
 F069      7C        3966       DB      124T     ; x=105        ;=2.059v
 F06A      7D        3967       DB      125T     ; x=106        ;=2.078v
 F06B      7E        3968       DB      126T     ; x=107        ;=2.098v
 F06C      7F        3969       DB      127T     ; x=108        ;=2.118v
 F06D      80        3970       DB      128T     ; x=109        ;=2.137v
 F06E      81        3971       DB      129T     ; x=110        ;=2.157v
 F06F      83        3972       DB      131T     ; x=111        ;=2.176v
 F070      84        3973       DB      132T     ; x=112        ;=2.196v
 F071      85        3974       DB      133T     ; x=113        ;=2.216v
 F072      86        3975       DB      134T     ; x=114        ;=2.235v
 F073      87        3976       DB      135T     ; x=115        ;=2.255v
 F074      89        3977       DB      137T     ; x=116        ;=2.275v
 F075      8A        3978       DB      138T     ; x=117        ;=2.294v
 F076      8B        3979       DB      139T     ; x=118        ;=2.314v
 F077      8C        3980       DB      140T     ; x=119        ;=2.333v
 F078      8D        3981       DB      141T     ; x=120        ;=2.353v
 F079      8E        3982       DB      142T     ; x=121        ;=2.373v
 F07A      90        3983       DB      144T     ; x=122        ;=2.392v
 F07B      91        3984       DB      145T     ; x=123        ;=2.412v
 F07C      92        3985       DB      146T     ; x=124        ;=2.431v
 F07D      93        3986       DB      147T     ; x=125        ;=2.451v
 F07E      94        3987       DB      148T     ; x=126        ;=2.471v
 F07F      95        3988       DB      149T     ; x=127        ;=2.490v
 F080      97        3989       DB      151T     ; x=128        ;=2.510v
 F081      98        3990       DB      152T     ; x=129        ;=2.529v
 F082      99        3991       DB      153T     ; x=130        ,=2.549v
 F083      9A        3992       DB      154T     ; x=131        ;=2.569v
 F084      9B        3993       DB      155T     ; x=132        ;=2.588v
 F085      9C        3994       DB      156T     ; x=133        ;=2.608v
 F086      9E        3995       DB      158T     ; x=134        ;=2.627v
 F087      9F        3996       DB      159T     ; x=135        ;=2.647v
 F088      A0        3997       DB      160T     ; x=136        ;=2.667v
 F089      A1        3998       DB      161T     ; x=137        ;=2.686v
 F08A      A2        3999       DB      162T     ; x=138        ;=2.706v
 F08B      A4        4000       DB      164T     ; x=139        ;=2.725v


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 40
MC68HC908GP32 User Bootloader


 F08C      A5        4001       DB      165T     ; x=140        ;=2.745v
 F08D      A6        4002       DB      166T     ; x=141        ;=2.765v
 F08E      A7        4003       DB      167T     ; x=142        ;=2.784v
 F08F      A8        4004       DB      168T     ; x=143        ;=2.804v
 F090      A9        4005       DB      169T     ; x=144        ;=2.824V
 F091      AB        4006       DB      171T     ; x=145        ;=2.843v
 F092      AC        4007       DB      172T     ; x=146        ;=2.863v
 F093      AD        4008       DB      173T     ; x=147        ;=2.882v
 F094      AE        4009       DB      174T     ; x=148        ;=2.902v
 F095      AF        4010       DB      175T     ; x=149        ;=2.922v
 F096      B0        4011       DB      176T     ; x=150        ;=2.941v
 F097      B2        4012       DB      178T     ; x=151        ;=2.961v
 F098      B3        4013       DB      179T     ; x=152        ;=2.980v
 F099      B4        4014       DB      180T     ; x=153        ;=3.000v
 F09A      B5        4015       DB      181T     ; x=154        ;=3.020v
 F09B      B6        4016       DB      182T     ; x=155        ;=3.039v
 F09C      B8        4017       DB      184T     ; x=156        ;=3.059v
 F09D      B9        4018       DB      185T     ; x=157        ;=3.078v
 F09E      BA        4019       DB      186T     ; x=158        ;=3.098v
 F09F      BB        4020       DB      187T     ; x=159        ;=3.118v
 F0A0      12        4021       DB      18T      ; x=160        ;=3.137v
 F0A1      BD        4022       DB      189T     ; x=161        ;=3.157v
 F0A2      BF        4023       DB      191T     ; x=162        ;=3.176v
 F0A3      C0        4024       DB      192T     ; x=163        ;=3.196v
 F0A4      C1        4025       DB      193T     ; x=164        ;=3.216v
 F0A5      C2        4026       DB      194T     ; x=165        ;=3.235v
 F0A6      C3        4027       DB      195T     ; x=166        ;=3.255v
 F0A7      C5        4028       DB      197T     ; x=167        ;=3.275v
 F0A8      C6        4029       DB      198T     ; x=168        ;=3.294v
 F0A9      C7        4030       DB      199T     ; x=169        ;=3.314v
 F0AA      C8        4031       DB      200T     ; x=170        ;=3.333v
 F0AB      C9        4032       DB      201T     ; x=171        ;=3.353v
 F0AC      CA        4033       DB      202T     ; x=172        ;=3.373v
 F0AD      CC        4034       DB      204T     ; x=173        ;=3.392v
 F0AE      CD        4035       DB      205T     ; x=174        ;=3.412v
 F0AF      CE        4036       DB      206T     ; x=175        ;=3.431v
 F0B0      CF        4037       DB      207T     ; x=176        ;=3.451v
 F0B1      D0        4038       DB      208T     ; x=177        ;=3.471v
 F0B2      D1        4039       DB      209T     ; x=178        ;=3.490v
 F0B3      D3        4040       DB      211T     ; x=179        ;=3.510v
 F0B4      D4        4041       DB      212T     ; x=180        ;=3.529v
 F0B5      D5        4042       DB      213T     ; x=181        ;=3.549v
 F0B6      D6        4043       DB      214T     ; x=182        ;=3.569v
 F0B7      D7        4044       DB      215T     ; x=183        ;=3.588v
 F0B8      D8        4045       DB      216T     ; x=184        ;=3.608v
 F0B9      DA        4046       DB      218T     ; x=185        ;=3.627v
 F0BA      DB        4047       DB      219T     ; x=186        ;=3.647v
 F0BB      DC        4048       DB      220T     ; x=187        ;=3.667v
 F0BC      DD        4049       DB      221T     ; x=188        ;=3.686v
 F0BD      DE        4050       DB      222T     ; x=189        ;=3.706v
 F0BE      E0        4051       DB      224T     ; x=190        ;=3.725v
 F0BF      E1        4052       DB      225T     ; x=191        ;=3.745v
 F0C0      E2        4053       DB      226T     ; x=192        ;=3.765v
 F0C1      E3        4054       DB      227T     ; x=193        ;=3.784v
 F0C2      E4        4055       DB      228T     ; x=194        ;=3.804v
 F0C3      E5        4056       DB      229T     ; x=195        ;=3.824v
 F0C4      E7        4057       DB      231T     ; x=196        ;=3.843v
 F0C5      E8        4058       DB      232T     ; x=197        ;=3.863v
 F0C6      E9        4059       DB      233T     ; x=198        ;=3.882v
 F0C7      EA        4060       DB      234T     ; x=199        ;=3.902v
 F0C8      EB        4061       DB      235T     ; x=200        ;=3.922v
 F0C9      EC        4062       DB      236T     ; x=201        ;=3.941v
 F0CA      EE        4063       DB      238T     ; x=202        ;=3.961v
 F0CB      EF        4064       DB      239T     ; x=203        ;=3.980v
 F0CC      F0        4065       DB      240T     ; x=204        ;=4.000v
 F0CD      F1        4066       DB      241T     ; x=205        ;=4.020v
 F0CE      F2        4067       DB      242T     ; x=206        ;=4.039v
 F0CF      F4        4068       DB      244T     ; x=207        ;=4.059v
 F0D0      F5        4069       DB      245T     ; x=208        ;=4.078v
 F0D1      F6        4070       DB      246T     ; x=209        ;=4.098v
 F0D2      F7        4071       DB      247T     ; x=210        ;=4.118v
 F0D3      F8        4072       DB      248T     ; x=211        ;=4.137v
 F0D4      F9        4073       DB      249T     ; x=212        ;=4.157v
 F0D5      FA        4074       DB      250T     ; x=213        ;=4.176v
 F0D6      FC        4075       DB      252T     ; x=214        ;=4.196v
 F0D7      FD        4076       DB      253T     ; x=215        ;=4.216v
 F0D8      FE        4077       DB      254T     ; x=216        ;=4.235v
 F0D9      FF        4078       DB      255T     ; x=217        ;=4.255v
 F0DA      FF        4079       DB      255T     ; x=218        ;=4.275v
 F0DB      FF        4080       DB      255T     ; x=219        ;=4.294v
 F0DC      FF        4081       DB      255T     ; x=220        ;=4.314v
 F0DD      FF        4082       DB      255T     ; x=221        ;=4.333v


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 41
MC68HC908GP32 User Bootloader


 F0DE      FF        4083       DB      255T     ; x=222        ;=4.353v
 F0DF      FF        4084       DB      255T     ; x=223        ;=4.373v
 F0E0      FF        4085       DB      255T     ; x=224        ;=4.392v
 F0E1      FF        4086       DB      255T     ; x=225        ;=4.412v
 F0E2      FF        4087       DB      255T     ; x=226        ;=4.431v
 F0E3      FF        4088       DB      255T     ; x=227        ;=4.451v
 F0E4      FF        4089       DB      255T     ; x=228        ;=4.471v
 F0E5      FF        4090       DB      255T     ; x=229        ;=4.490v
 F0E6      FF        4091       DB      255T     ; x=230        ;=4.510v
 F0E7      FF        4092       DB      255T     ; x=231        ;=4.529v
 F0E8      FF        4093       DB      255T     ; x=232        ;=4.549v
 F0E9      FF        4094       DB      255T     ; x=233        ;=4.569v
 F0EA      FF        4095       DB      255T     ; x=234        ;=4.588v
 F0EB      FF        4096       DB      255T     ; x=235        ;=4.608v
 F0EC      FF        4097       DB      255T     ; x=236        ;=4.627v
 F0ED      FF        4098       DB      255T     ; x=237        ;=4.647v
 F0EE      FF        4099       DB      255T     ; x=238        ;=4.667v
 F0EF      FF        4100       DB      255T     ; x=239        ;=4.686v
 F0F0      FF        4101       DB      255T     ; x=240        ;=4.706v
 F0F1      FF        4102       DB      255T     ; x=241        ;=4.725v
 F0F2      FF        4103       DB      255T     ; x=242        ;=4.745v
 F0F3      FF        4104       DB      255T     ; x=243        ;=4.765v
 F0F4      FF        4105       DB      255T     ; x=244        ;=4.784v
 F0F5      FF        4106       DB      255T     ; x=245        ;=4.804v
 F0F6      FF        4107       DB      255T     ; x=246        ;=4.824v
 F0F7      FF        4108       DB      255T     ; x=247        ;=4.843v
 F0F8      FF        4109       DB      255T     ; x=248        ;=4.863v
 F0F9      FF        4110       DB      255T     ; x=249        ;=4.882v
 F0FA      FF        4111       DB      255T     ; x=250        ;=4.902v
 F0FB      FF        4112       DB      255T     ; x=251        ;=4.922v
 F0FC      FF        4113       DB      255T     ; x=252        ;=4.941v
 F0FD      FF        4114       DB      255T     ; x=253        ;=4.961v
 F0FE      FF        4115       DB      255T     ; x=254        ;=4.980v
 F0FF      00        4116       DB      0T       ; x=255        ;=5.000v        ;=sens fail
                     4117  
 F100                4118       include "DecBCD.inc"    ; table=DecBCD:,     offset=Dec,  result=BCD
                     4119  DecBCD:
 F100      00        4120       DB      0T       ; x=000        00000000 = 00000000
 F101      01        4121       DB      1T       ; x=001        00000001 = 00000001
 F102      02        4122       DB      2T       ; x=002        00000010 = 00000010
 F103      03        4123       DB      3T       ; x=003        00000011 = 00000011
 F104      04        4124       DB      4T       ; x=004        00000100 = 00000100
 F105      05        4125       DB      5T       ; x=005        00000101 = 00000101
 F106      06        4126       DB      6T       ; x=006        00000110 = 00000110
 F107      07        4127       DB      7T       ; x=007        00000111 = 00000111
 F108      08        4128       DB      8T       ; x=008        00001000 = 00001000
 F109      09        4129       DB      9T       ; x=009        00001001 = 00001001
 F10A      10        4130       DB      16T      ; x=010        00001010 = 00010000
 F10B      11        4131       DB      17T      ; x=011        00001011 = 00010001 
 F10C      12        4132       DB      18T      ; x=012        00001100 = 00010010 
 F10D      13        4133       DB      19T      ; x=013        00001101 = 00010011
 F10E      14        4134       DB      20T      ; x=014        00001110 = 00010100 
 F10F      15        4135       DB      21T      ; x=015        00001111 = 00010101 
 F110      16        4136       DB      22T      ; x=016        00010000 = 00010110 
 F111      17        4137       DB      23T      ; x=017        00010001 = 00010111 
 F112      18        4138       DB      24T      ; x=018        00010010 = 00011000
 F113      19        4139       DB      25T      ; x=019        00010011 = 00011001 
 F114      20        4140       DB      32T      ; x=020        00010100 = 00100000 
 F115      21        4141       DB      33T      ; x=021        00010101 = 00100001 
 F116      22        4142       DB      34T      ; x=022        00010110 = 00100010  
 F117      23        4143       DB      35T      ; x=023        00010111 = 00100011  
 F118      24        4144       DB      36T      ; x=024        00011000 = 00100100  
 F119      25        4145       DB      37T      ; x=025        00011001 = 00100101  
 F11A      26        4146       DB      38T      ; x=026        00011010 = 00100110  
 F11B      27        4147       DB      39T      ; x=027        00011011 = 00100111 
 F11C      28        4148       DB      40T      ; x=028        00011100 = 00101000  
 F11D      29        4149       DB      41T      ; x=029        00011101 = 00101001  
 F11E      30        4150       DB      48T      ; x=030        00011110 = 00110000
 F11F      31        4151       DB      49T      ; x=031        00011111 = 00110001
 F120      32        4152       DB      50T      ; x=032        00100000 = 00110010
 F121      33        4153       DB      51T      ; x=033        00100001 = 00110011
 F122      34        4154       DB      52T      ; x=034        00100010 = 00110100
 F123      35        4155       DB      53T      ; x=035        00100011 = 00110101
 F124      36        4156       DB      54T      ; x=036        00100100 = 00110110
 F125      37        4157       DB      55T      ; x=037        00100101 = 00110111 
 F126      38        4158       DB      56T      ; x=038        00100110 = 00111000
 F127      39        4159       DB      57T      ; x=039        00100111 = 00111001
 F128      40        4160       DB      64T      ; x=040        00101000 = 01000000
 F129      41        4161       DB      65T      ; x=041        00101001 = 01000001
 F12A      42        4162       DB      66T      ; x=042        00101010 = 01000010
 F12B      43        4163       DB      67T      ; x=043        00101011 = 01000011
 F12C      44        4164       DB      68T      ; x=044        00101100 = 01000100


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 42
MC68HC908GP32 User Bootloader


 F12D      45        4165       DB      69T      ; x=045        00101101 = 01000101
 F12E      46        4166       DB      70T      ; x=046        00101110 = 01000110
 F12F      47        4167       DB      71T      ; x=047        00101111 = 01000111
 F130      48        4168       DB      72T      ; x=048        00110000 = 01001000
 F131      49        4169       DB      73T      ; x=049        00110001 = 01001001
 F132      50        4170       DB      80T      ; x=050        00110010 = 01010000
 F133      51        4171       DB      81T      ; x=051        00110011 = 01010001
 F134      52        4172       DB      82T      ; x=052        00110100 = 01010010
 F135      53        4173       DB      83T      ; x=053        00110101 = 01010011
 F136      54        4174       DB      84T      ; x=054        00110110 = 01010100
 F137      55        4175       DB      85T      ; x=055        00110111 = 01010101
 F138      56        4176       DB      86T      ; x=056        00111000 = 01010110
 F139      57        4177       DB      87T      ; x=057        00111001 = 01010111
 F13A      58        4178       DB      88T      ; x=058        00111010 = 01011000
 F13B      59        4179       DB      89T      ; x=059        00111011 = 01011001
 F13C      60        4180       DB      96T      ; x=060        00111100 = 01100000
 F13D      61        4181       DB      97T      ; x=061        00111101 = 01100001
 F13E      62        4182       DB      98T      ; x=062        00111110 = 01100010
 F13F      63        4183       DB      99T      ; x=063        00111111 = 01100011
 F140      64        4184       DB      100T     ; x=064        01000000 = 01100100
 F141      65        4185       DB      101T     ; x=065        01000001 = 01100101
 F142      66        4186       DB      102T     ; x=066        01000010 = 01100110
 F143      67        4187       DB      103T     ; x=067        01000011 = 01100111
 F144      68        4188       DB      104T     ; x=068        01000100 = 01101000
 F145      69        4189       DB      105T     ; x=069        01000101 = 01101001
 F146      70        4190       DB      112T     ; x=070        01000110 = 01110000
 F147      71        4191       DB      113T     ; x=071        01000111 = 01110001
 F148      72        4192       DB      114T     ; x=072        01001000 = 01110010
 F149      73        4193       DB      115T     ; x=073        01001001 = 01110011
 F14A      74        4194       DB      116T     ; x=074        01001010 = 01110100
 F14B      75        4195       DB      117T     ; x=075        01001011 = 01110101
 F14C      76        4196       DB      118T     ; x=076        01001100 = 01110110
 F14D      77        4197       DB      119T     ; x=077        01001101 = 01110111
 F14E      78        4198       DB      120T     ; x=078        01001110 = 01111000
 F14F      79        4199       DB      121T     ; x=079        01001111 = 01111001
 F150      80        4200       DB      128T     ; x=080        01010000 = 10000000
 F151      81        4201       DB      129T     ; x=081        01010001 = 10000001
 F152      82        4202       DB      130T     ; x=082        01010010 = 10000010
 F153      83        4203       DB      131T     ; x=083        01010011 = 10000011
 F154      84        4204       DB      132T     ; x=084        01010100 = 10000100
 F155      85        4205       DB      133T     ; x=085        01010101 = 10000101
 F156      86        4206       DB      134T     ; x=086        01010110 = 10000110
 F157      87        4207       DB      135T     ; x=087        01010111 = 10000111
 F158      88        4208       DB      136T     ; x=088        01011000 = 10001000
 F159      89        4209       DB      137T     ; x=089        01011001 = 10001001
 F15A      90        4210       DB      144T     ; x=090        01011010 = 10010000
 F15B      91        4211       DB      145T     ; x=091        01011011 = 10010001
 F15C      92        4212       DB      146T     ; x=092        01011100 = 10010010
 F15D      93        4213       DB      147T     ; x=093        01011101 = 10010011
 F15E      94        4214       DB      148T     ; x=094        01011110 = 10010100
 F15F      95        4215       DB      149T     ; x=095        01011111 = 10010101
 F160      96        4216       DB      150T     ; x=096        10000000 = 10010110
 F161      97        4217       DB      151T     ; x=097        10000001 = 10011111
 F162      98        4218       DB      152T     ; x=098        10000010 = 10011000
 F163      99        4219       DB      153T     ; x=099        10000011 = 10011001
                     4220  
                     4221  
                     4222  ;***************************************************************************
                     4223  ; - Start of bootloader-defined jump table/vector
                     4224  ;***************************************************************************
                     4225  
 FAC3                4226       org     $FAC3              ; start bootloader-defined jump table/vector
                     4227                                  ;(64195)
 FAC3      12        4228       db      $12                ; scbr regi init value
 FAC4      01        4229       db      %00000001          ; config1
 FAC5      01        4230       db      %00000001          ; config2
 FAC6      8100      4231       dw      {rom_start + 256}  ; megasquirt code start
 FAC8      FB00      4232       dw      $FB00              ; bootloader start(64256)
                     4233  
                     4234  ;****************************************************************************
                     4235  ; - Vector table (origin vec_timebase)
                     4236  ;****************************************************************************
                     4237  
 FACA      CC        4238          db      $CC
 FACB      8685      4239       dw      Dummy          ;Time Base Vector
 FACD      CC        4240          db      $CC
 FACE      8668      4241       dw      ADC_ISR        ;ADC Conversion Complete
 FAD0      CC        4242          db      $CC
 FAD1      8685      4243       dw      Dummy          ;Keyboard Vector
 FAD3      CC        4244          db      $CC
 FAD4      8635      4245       dw      SCITX_ISR      ;SCI Transmit Vector
 FAD6      CC        4246          db      $CC


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 43
MC68HC908GP32 User Bootloader


 FAD7      85A8      4247       dw      SCIRCV_ISR     ;SCI Receive Vector
 FAD9      CC        4248          db      $CC
 FADA      8685      4249       dw      Dummy          ;SCI Error Vector
 FADC      CC        4250          db      $CC
 FADD      8685      4251       dw      Dummy          ;SPI Transmit Vector
 FADF      CC        4252          db      $CC
 FAE0      8685      4253       dw      Dummy          ;SPI Receive Vector
 FAE2      CC        4254          db      $CC
 FAE3      8685      4255       dw    Dummy          ;TIM2 Overflow Vector
 FAE5      CC        4256          db      $CC
 FAE6      8685      4257       dw    Dummy          ;TIM2 Ch1 Vector
 FAE8      CC        4258          db      $CC
 FAE9      855A      4259       dw      TIM2CH0_ISR    ;TIM2 Ch0 Vector
 FAEB      CC        4260          db      $CC
 FAEC      853D      4261       dw      TIM1OV_ISR     ;TIM1 Overflow Vector
 FAEE      CC        4262          db      $CC
 FAEF      8685      4263       dw      Dummy          ;TIM1 Ch1 Vector
 FAF1      CC        4264          db      $CC
 FAF2      8685      4265       dw      Dummy          ;TIM1 Ch0 Vector
 FAF4      CC        4266          db      $CC
 FAF5      8685      4267       dw      Dummy          ;PLL Vector
 FAF7      CC        4268          db      $CC
 FAF8      8685      4269       dw      Dummy          ;IRQ Vector
 FAFA      CC        4270          db      $CC
 FAFB      8685      4271       dw      Dummy          ;SWI Vector
 FAFD      CC        4272          db      $CC
 FAFE      8256      4273       dw      Start          ;Reset Vector
                     4274  
 FB00                4275       end
                     4276  
                     4277   

 Symbol Table 

ACK              0002
ACKK             0002
ACQ              0005
ADCC             0001
ADCH0            0000
ADCH1            0001
ADCH2            0002
ADCH3            0003
ADCH4            0004
ADCLK            003E
ADCO             0005
ADCWAIT          83CD
ADCWAIT1         83D8
ADCWAIT2         83E3
ADCWAIT3         83EE
ADC_ISR          8668
ADC_LOOKUPS      8409
ADICLK           0004
ADIV0            0005
ADIV1            0006
ADIV2            0007
ADR              003D
ADSCR            003C
ADSEL            006D
AIEN             0006
ASCII_CR         000D
ASCII_LF         000A
AUTO             0007
BAT              0044
BATVOLT          F000
BCFE             0007
BCS              0004
BKF              0001
BLANK            00A8
BOOT             FBBB
BOOT1            FBD9
BOOT2            FBE0
BOOT3            FBFC
BOOT4            FC4A
BOOT5            FCBE
BOOT6            FCC6
BOOT7            FCCC
BOOTDONE         FBE6
BOOTDONE1        FBE9
BOOTDONE2        FBEB
BOOTEND          FDF8
BOOTPROG         FC04
BOOTPROG1        FC07


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 44
MC68HC908GP32 User Bootloader


BOOTPROG2        FC14
BOOTPROG3        FC2D
BOOTPROG4        FC31
BOOTPROG5        FC42
BOOTPROG6        FC47
BOOTRESET        FB08
BOOTRESET1       FB59
BOOTRESET2       FB75
BOOTRESET3       FB7E
BOOTRESET4       FB87
BOOTRESET5       FB98
BOOTRESET6       FBA5
BOOTRESETUSER    FBA5
BOOT_START       FB00
BRKA             0006
BRKE             0007
BRKH             FE09
BRKL             FE0A
BRKSCR           FE0B
BURNBYTE         881C
BURNCONST        87F6
BURNCOUNT        0095
BURNDST          0093
BURNSRC          0091
BUS7372800       FB00
BUS8003584       FB04
CGMCHANGE        FB39
CHECK_GREATER_TH 86B0
CHECK_LESS_THAN  86A8
CHECK_TXCMD      85CC
CHXF             0007
CHXIE            0006
CHXMAX           0000
CLK10            0000
CMD_ERASE        0057
CMD_EXIT         0058
CMD_HELP         0048
CMD_HELP1        001F
CMD_PROGRAM      0050
CMD_UPGRADE      0055
COCO             0007
CONFIG1          001F
CONFIG2          001E
CONT_TX          8651
COP              0005
COPCTL           FFFF
COUNT            0040
CPHA             0003
CPOL             0004
DDRA             0004
DDRB             0005
DDRC             0006
DDRD             0007
DDRE             000C
DECBCD           F100
DECRMT           8757
DELAY            FD39
DELAY1           FD3A
DELAY2           FD3C
DISP_SEQ         84A7
DISP_SEQ_DONE    84C4
DIVIDEND         0071
DIVISOR          0073
DIVROUND         8781
DIVROUND0        8791
DIVROUND1        8793
DIVROUND2        878E
DMARE            0005
DMATE            0004
DONE_RCV         8633
DONE_WITH_INTERP 86F4
DONE_XFER        8666
DO_100HZ         8583
DO_INTERP        86BB
DSEL             0097
DUMMY            8685
ELSXA            0002
ELSXB            0003
ENSCI            0006
ERASE            0002
ERASEFLASH       FC5C
ERASEFLASH1      FC5F


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 45
MC68HC908GP32 User Bootloader


ERASERAMSIZE     003B
ERRIE            0006
FE               0001
FEIE             0001
FIRE_ADC         8570
FLASHPROGRAM     FD44
FLASHPROGRAM1    FD4E
FLASHPROGRAM2    FD7F
FLASH_ERASED     00FF
FLASH_FIRST      0043
FLASH_LAST       0045
FLASH_PAGE       0080
FLASH_PROTECT    00F6
FLASH_ROW        0040
FLBPR            FF7E
FLCR             FE08
GETCHAR          FC6A
GETHEXBYTE       FCD2
GETHEXBYTE1      FCEA
GETHEXBYTE2      FCEC
GETSREC          FC73
GETSREC1         FC78
GETSREC1A        FC80
GETSREC2         FC92
GETSREC3         FCA7
GETSREC4         FCBB
GOT_ORD_NUM      86A2
HVEN             0008
IDLE             0004
ILAD             0003
ILIE             0004
ILOP             0004
ILTY             0002
IMASK            0001
IMASKK           0001
INC_CUS          8565
INC_MS           8576
INC_MSX10        8591
INC_S            859E
INIT_CONFIG1     0001
INIT_CONFIG2     0001
INIT_FIRST       8000
INIT_LAST        FB00
INIT_SCBR        0012
INIT_SCC1        0040
INIT_SCC2        000C
INIT_STACK       01EC
INPUTS           006E
INT1             FE04
INT2             FE05
INT3             FE06
INTACC1          006F
INTACC2          0073
INTKBIER         001B
INTKBSCR         001A
INTSCR           001D
IN_A_OR_C_MODE   8646
IN_Q_MODE        864E
IN_V_MODE        864A
IRQF             0003
ISHEX            FCF6
ISHEX1           FD06
ISNTHEX          FD08
KBIE0            0000
KBIE1            0001
KBIE2            0002
KBIE3            0003
KBIE4            0004
KBIE5            0005
KBIE6            0006
KBIE7            0007
KEYF             0003
LININTERP        86A3
LOAD_RAM         82D3
LOCAL_TMP        008C
LOCK             0006
LOOPCHK_DONE     8403
LOOPCNTR         0096
LOOPER           83F9
LOOPFRQ          0003
LOOPS            0007
LOOP_END         853A


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 46
MC68HC908GP32 User Bootloader


LVI              0001
LVIOUT           0007
LVISR            FE0C
M                0004
MASS             0004
MASSERASE        FD09
MASSERASE1       FD0D
MASSERASE2       FD30
MODE             0000
MODEK            0000
MODE_A           85E6
MODE_B           85F6
MODE_C           85FD
MODE_Q           8623
MODE_V           860D
MODE_W           861D
MODF             0004
MODFEN           0002
MODRST           0002
MS               0069
MSG_COMPLETE     FDB4
MSG_ERROR        FDCE
MSG_HELLO        FD88
MSG_HELP         FD90
MSG_NORESET      FDE0
MSG_WAITING      FDBF
MSG_WHAT         FDD7
MSX10            006A
MSX100           006C
MSX20            006B
MSXA             0004
MSXB             0005
MS_DELAY         8871
MS_DELAY1        8872
MS_DELAY2        8874
MS_ERASEFLASH    882F
MS_ERASEFLASH1   8832
MS_ERASERAMSIZE  0031
MS_FLASHPROGRAM  887C
MS_FLASHPROGRAM1 887C
MS_FLASHPROGRAM2 88AB
MS_MASSERASE     884B
MS_PROGRAMFLASH  883D
MS_PROGRAMFLASH1 8840
MS_PROGRAMRAM    000B
MS_PROGRAMRAMSIZ 004A
MS_RAM_END       00A0
MS_RAM_SIZE      0060
MS_RAM_START     0040
MS_RF_END        00E8
MS_RF_END_F      E140
MS_RF_SIZE       0048
MS_RF_START      00A0
MS_RF_START_F    E100
MS_TOTAL_RAM_SIZ 00A8
NEG_SLOPE        86E7
NEIE             0002
NEW_ADC          8681
NF               0002
NO_ADC_PASS      84A1
NO_DISP_PASS     84C6
NO_PW_CALCS      853A
OR               0003
ORD_TABLE_FIND   8686
ORIE             0003
OVRF             0005
PBCD             0049
PBWC             0037
PCTL             0036
PE               0000
PEIE             0000
PEN              0001
PGM              0001
PIN              0006
PLLF             0006
PLLIE            0007
PLLON            0005
PLLSET           FB3D
PLLWAIT          FB4D
PLL_WAIT         8271
PLSD             0006
PLSDBCD          004C


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 47
MC68HC908GP32 User Bootloader


PMDS             003B
PMRS             003A
PMSD             0007
PMSDBCD          004D
PMSH             0038
PMSL             0039
POR              0007
PORTA            0000
PORTB            0001
PORTC            0002
PORTD            0003
PORTE            0008
POSINTERP        86CE
POTPPCT          0046
POTPPOS          0043
POTPP_CALC       844F
POTP_HI          8473
POTP_LOW         846E
POTSPCT          0045
POTSPOS          0042
POTSP_CALC       8409
POTS_HI          842D
POTS_LOW         8428
PRE0             0002
PRE1             0003
PRINTSTRING      FBF8
PRINTSTRING1     FBF3
PROGRAMRAM       000B
PROGRAMRAMSIZE   004F
PS0              0000
PS1              0001
PS2              0002
PTAPUE           000D
PTCPUE           000E
PTDPUE           000F
PTY              0000
PUTCHAR          FB53
PUTSTRING        FBED
PWP              0002
PW_CALCS         84CC
P_BCD_CALC       8476
P_LSD_CALC       8480
QUOTIENT         006F
R8               0007
RAM_EXEC         01ED
RAM_LAST         023F
RAM_START        0040
RE               0002
REENT            868F
REMAINDER        006F
REVNUM           E000
ROLL_ADC         867F
ROLL_DIS         858F
ROM_LAST         FDFF
ROM_START        8000
RPF              0000
RWU              0001
RXOFFSET         0090
SBCD             0048
SBFCR            FE03
SBK              0000
SBSR             FE00
SBSW             0001
SCBR             0019
SCC1             0013
SCC2             0014
SCC3             0015
SCDR             0018
SCIRCV_ISR       85A8
SCITX_ISR        8635
SCRF             0005
SCRIE            0005
SCS1             0016
SCS2             0017
SCTE             0007
SCTIE            0007
SECH             0040
SECL             0041
SETLSB           8755
SET_LOOPCHK      8401
SET_PLSD         84BC
SET_PMSD         84C1


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 48
MC68HC908GP32 User Bootloader


SET_SMSD         84B7
SHFTLP           8719
SIGNATURE        E001
SLSD             0004
SLSDBCD          004A
SMSD             0005
SMSDBCD          004B
SPARE1           0098
SPARE2           0099
SPARE3           009A
SPARE4           009B
SPARE5           009C
SPARE6           009D
SPARE7           009E
SPARE8           009F
SPCR             0010
SPDR             0012
SPE              0001
SPMSTR           0005
SPMULH           0061
SPMULL           0063
SPMULM           0062
SPPOSH           0064
SPPOSL           0065
SPPWMNH          005B
SPPWMNH_F        00A4
SPPWMNL          005C
SPPWMNL_F        00A5
SPPWMXH          005D
SPPWMXH_F        00A6
SPPWMXL          005E
SPPWMXL_F        00A7
SPPWSPNH         005F
SPPWSPNL         0060
SPR0             0000
SPR1             0001
SPRF             0007
SPRIE            0007
SPSCR            0011
SPTE             0003
SPTIE            0000
SPWOM            0002
SP_RND_DONE      8525
SRECADDR         0007
SRECCHKSUM       0002
SRECCOUNT        0001
SRECSIZE         0006
SRECTYPE         0005
SREDDATA         0008
SRSR             FE01
SRVP             0004
SRVPPWH          0066
SRVPPWL          0067
SRVS             0005
SRVSPWH          0059
SRVSPWL          005A
SSMULH           0054
SSMULL           0056
SSMULM           0055
SSPOSH           0057
SSPOSL           0058
SSPWMNH          004E
SSPWMNH_F        00A0
SSPWMNL          004F
SSPWMNL_F        00A1
SSPWMXH          0050
SSPWMXH_F        00A2
SSPWMXL          0051
SSPWMXL_F        00A3
SSPWSPNH         0052
SSPWSPNL         0053
SS_RND_DONE      84EF
START            8256
STB_ADC          83C5
SUBAR            FE02
S_BCD_CALC       8430
S_LSD_CALC       843A
T1CH0H           0026
T1CH0L           0027
T1CH1H           0029
T1CH1L           002A
T1CNTH           0021


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 49
MC68HC908GP32 User Bootloader


T1CNTL           0022
T1MODH           0023
T1MODL           0024
T1SC             0020
T1SC0            0025
T1SC1            0028
T2CH0H           0031
T2CH0L           0032
T2CH1H           0034
T2CH1L           0035
T2CNTH           002C
T2CNTL           002D
T2MODH           002E
T2MODL           002F
T2SC             002B
T2SC0            0030
T2SC1            0033
T8               0006
TACK             0003
TBCR             001C
TBIE             0002
TBIF             0007
TBON             0001
TBR0             0004
TBR1             0005
TBR2             0006
TC               0006
TCIE             0006
TE               0003
TEMP_SP          0041
TIM1OV_ISR       853D
TIM2CH0_ISR      855A
TIM2CH0_ISR_DONE 85A6
TMP1             0077
TMP10            0080
TMP11            0081
TMP12            0082
TMP13            0083
TMP14            0084
TMP15            0085
TMP16            0086
TMP17            0087
TMP18            0088
TMP19            0089
TMP2             0078
TMP20            008A
TMP21            008B
TMP3             0079
TMP4             007A
TMP5             007B
TMP6             007C
TMP7             007D
TMP8             007E
TMP9             007F
TOF              0007
TOHEX            FCED
TOHEX1           FCF5
TOIE             0006
TOVX             0001
TRST             0004
TSTOP            0005
TXCNT            008D
TXGOAL           008E
TXINV            0005
TXMODE           008F
TXMODE_5         85B7
TXMODE_6         85BF
UDIVBY100        87DC
UDIVROUNDINGDONE 87F5
UDVD32           86F5
UMUL16           87CB
UMUL32           8794
UMUL32A          87B8
UMUL32B          87CA
UMULANDDIV       87CB
USER_ADC         FACD
USER_CONFIG1     FAC4
USER_CONFIG2     FAC5
USER_FIRST       FAC6
USER_IRQ         FAF7
USER_KEYBOARD    FAD0
USER_LAST        FAC8


MS_Servo_V1.asm        Assembled with CASM08Z  11/24/05  4:19:22 PM  PAGE 50
MC68HC908GP32 User Bootloader


USER_PLL         FAF4
USER_RESET       FAFD
USER_SCBR        FAC3
USER_SCIERR      FAD9
USER_SCIRX       FAD6
USER_SCITX       FAD3
USER_SPIRX       FADF
USER_SPITX       FADC
USER_SWI         FAFA
USER_TIM1CH0     FAF1
USER_TIM1CH1     FAEE
USER_TIM1OV      FAEB
USER_TIM2CH0     FAE8
USER_TIM2CH1     FAE5
USER_TIM2OV      FAE2
USER_TIMEBASE    FACA
USX100           0068
VEC_ADC          FFDE
VEC_IRQ          FFFA
VEC_KBD          FFE0
VEC_PLL          FFF8
VEC_RESET        FFFE
VEC_SCIERR       FFE6
VEC_SCIRX        FFE4
VEC_SCITX        FFE2
VEC_SPIRX        FFEA
VEC_SPITX        FFE8
VEC_SWI          FFFC
VEC_TIM1CH0      FFF6
VEC_TIM1CH1      FFF4
VEC_TIM1OV       FFF2
VEC_TIM2CH0      FFF0
VEC_TIM2CH1      FFEE
VEC_TIM2OV       FFEC
VEC_TIMEBASE     FFDC
VOLTS            0047
VOLTS_CALC       8495
VPR0             0000
VPR1             0001
WAKE             0003
ZERO_SLOPE       86F2
